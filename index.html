<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Love your Data üíô ‚Äì Complete v7</title>
  <style>
    :root{
      --bg:#0b0f17;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --mdm-blue:#6485c1; /* Future Blue */
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{
      height:100%; margin:0;
      background: radial-gradient(1200px 800px at 50% 0%, #111a2e 0%, var(--bg) 55%);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    .wrap{
      height:100%;
      display:flex; flex-direction:column;
      padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom) 12px;
      gap:10px;
      max-width: 980px; margin:0 auto;
    }
    header{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:10px; padding:10px 12px;
      background: linear-gradient(180deg, rgba(17,24,39,.72), rgba(17,24,39,.45));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .brand{display:flex; flex-direction:column; gap:4px; min-width:0;}
    .brand .t{
      font-weight:800; letter-spacing:.2px;
      display:flex; align-items:center; gap:8px; flex-wrap:wrap;
    }
    .sub{
      color:var(--muted);
      font-size:12.5px; line-height:1.25;
      max-width: 70ch;
    }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 10px; border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      font-size:12px; color: var(--muted);
      white-space:nowrap;
    }
    .pill .dot{
      width:8px; height:8px; border-radius:99px;
      background: var(--warn);
      box-shadow: 0 0 0 3px rgba(245,158,11,.15);
    }
    .pill.mdm{
      color:#e7eefc;
      border-color: rgba(100,133,193,.45);
      background: rgba(100,133,193,.16);
    }
    .pill.mdm .dot{
      background: var(--mdm-blue);
      box-shadow: 0 0 0 3px rgba(100,133,193,.22);
    }
    .actions{display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:700;
      font-size:14px; line-height:1;
      cursor:pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
      transition: transform .06s ease, background .2s ease, border-color .2s ease, opacity .2s ease;
      user-select:none;
    }
    button:active{transform: translateY(1px) scale(.99);}
    button.primary{border-color: rgba(100,133,193,.6); background: rgba(100,133,193,.18);}
    button.danger{border-color: rgba(239,68,68,.55); background: rgba(239,68,68,.14);}
    button.ghost{border-color: rgba(255,255,255,.10); background: rgba(255,255,255,.04);}
    .hud{
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:8px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(15,23,42,.72), rgba(15,23,42,.35));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .stat{display:flex; flex-direction:column; gap:4px; min-width:0;}
    .stat .k{font-size:12px; color: var(--muted);}
    .stat .v{font-size:16px; font-weight:850; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .bar{height:8px; border-radius:999px; background: rgba(255,255,255,.08); overflow:hidden; border:1px solid rgba(255,255,255,.08);}
    .bar > i{display:block; height:100%; width:50%; background: var(--good); transition: width .2s ease;}
    .stage{
      position:relative;
      overflow:hidden;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      background:
        radial-gradient(900px 700px at 50% 30%, rgba(100,133,193,.16) 0%, rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(17,24,39,.55), rgba(3,7,18,.72));
      box-shadow: var(--shadow);
      min-height: 360px;
      flex:1;
    }
    canvas{width:100%; height:100%; display:block;}
    .toast{
      position:absolute;
      top:10px; left:10px;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(17,24,39,.78);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      max-width: min(700px, calc(100% - 20px));
      transform: translateY(-6px);
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
      backdrop-filter: blur(10px);
      font-size:14px;
      line-height:1.25;
    }
    .toast.show{opacity:1; transform: translateY(0px);}
    .toast b{font-weight:900;}
    .toast .tag{
      display:inline-flex; align-items:center; gap:6px;
      margin-left:8px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }
    @media (min-width: 820px){
      header{padding:12px 14px;}
      .stage{min-height: 520px;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="t">
          Love your Data
          <span class="pill"><span class="dot"></span><span id="lvlLbl">Level 1</span></span>
          <span id="mdmPill" class="pill mdm" style="display:none;"><span class="dot"></span>MDM aktiv</span>
          <span id="timerPill" class="pill" style="display:none;">
            <span class="dot" style="background:rgba(255,255,255,.25); box-shadow:0 0 0 3px rgba(255,255,255,.08)"></span>
            <span id="timerLbl">120s</span>
          </span>
        </div>
        <div class="sub">
          Fixe Fehler. Merge Dubletten. üíô
        </div>
      </div>

      <div class="actions">
        <button id="btnPrev">‚óÄÔ∏é</button>
        <button id="btnNext" class="primary">Next ‚ñ∂Ô∏é</button>
        <button id="btnMdm" class="primary">MDM: Off</button>
        <button id="btnHeal" class="primary" style="display:none;">Stammdatenfehler beheben</button>
        <button id="btnSession" class="ghost">Session: On</button>
        <button id="btnDemo" class="ghost">Demo: Off</button>
        <button id="btnShare" class="primary">Share</button>
        <button id="btnReset" class="danger">Reset</button>
      </div>
    </header>

    <div class="hud">
      <div class="stat">
        <div class="k">Qualit√§t</div>
        <div class="v"><span id="qVal">100</span>%</div>
        <div class="bar"><i id="qBar" style="width:100%"></i></div>
      </div>
      <div class="stat">
        <div class="k">Systeme</div>
        <div class="v" id="sysVal">1</div>
        <div class="k" style="margin-top:2px;">Replikation</div>
        <div class="v" id="spreadVal">niedrig</div>
      </div>
      <div class="stat">
        <div class="k">Datens√§tze</div>
        <div class="v" id="recVal">10</div>
        <div class="k" style="margin-top:2px;">Fehler (rot)</div>
        <div class="v" id="errVal">0</div>
      </div>
      <div class="stat">
        <div class="k">Dubletten (orange)</div>
        <div class="v" id="dupVal">0</div>
        <div class="k" style="margin-top:2px;">Fixes</div>
        <div class="v" id="fixVal">0</div>
      </div>
      <div class="stat">
        <div class="k">Kosten</div>
        <div class="v" id="costVal">0 ‚Ç¨</div>
        <div class="k" style="margin-top:2px;">Zeit</div>
        <div class="v" id="timeVal">0.0</div>
      </div>
      <div class="stat">
        <div class="k">Score (Session)</div>
        <div class="v" id="scoreVal">0</div>
        <div class="k" style="margin-top:2px;">Produktivit√§t</div>
        <div class="v"><span id="prodVal">100</span>%</div>
        <div class="bar"><i id="prodBar" style="width:100%"></i></div>
      </div>
    </div>

    <div class="stage" id="stage">
      <canvas id="c"></canvas>
      <div class="toast" id="toast"></div>
    </div>
  </div>

  <script>
    // =========================
    // Utilities
    // =========================
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp  = (a,b,t)=>a+(b-a)*t;
    const rnd   = (a,b)=>a+Math.random()*(b-a);
    const now   = ()=>performance.now();
    const el = (id)=>document.getElementById(id);

    function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }
    function fmtEuro(n){ const v = Math.round(n); return v.toLocaleString("de-DE") + " ‚Ç¨"; }
    function qualityColor(q){ if(q>=80) return getCSS("--good"); if(q>=55) return getCSS("--warn"); return getCSS("--bad"); }
    function stars(n){ return "‚òÖ".repeat(n) + "‚òÜ".repeat(5-n); }

    // =========================
    // Canvas setup
    // =========================
    const canvas = document.getElementById("c");
    const stage  = document.getElementById("stage");
    const ctx    = canvas.getContext("2d", { alpha: true });

    // =========================
    // Content
    // =========================
    const SYSTEM_LABELS = [
      ["ERP"],
      ["ERP","CRM","Shop"],
      ["ERP","CRM","Shop","WMS","BI","Finance"],
      ["ERP","CRM","Shop","WMS","BI","Support","Finance","PIM","DataLake"],
      ["ERP","CRM","Shop","WMS","BI","Support","Finance","PIM","DataLake"]
    ];

    const SYSTEM_INFO = {
      "ERP":     { title:"ERP",      text:"Entstehung & Pflege von Stammdaten.", impact:"Fix hier = Ursache weg, wirkt in allen Folgesystemen." },
      "CRM":     { title:"CRM",      text:"Kundenpflege & Service-Kontext.",      impact:"Dubletten hier ‚Üí Kunde wird nicht erkannt." },
      "Shop":    { title:"Shop",     text:"Checkout nutzt replizierte Daten.",   impact:"Lokalfix m√∂glich ‚Äì aber Ursprung bleibt falsch." },
      "WMS":     { title:"WMS",      text:"Versand nutzt replizierte Daten.",    impact:"Lokalfix teuer; Fehler kann zur√ºckkommen." },
      "BI":      { title:"BI",       text:"Reports aggregieren replizierte Daten.", impact:"Falsche KPIs ‚Üí falsche Entscheidungen." },
      "Finance": { title:"Finance",  text:"Abrechnung nutzt replizierte Daten.", impact:"Fehler sp√§t = Reklamationen & Aufwand." },
      "Support": { title:"Support",  text:"Tickets brauchen saubere IDs.",       impact:"Kunde nicht auffindbar ‚Üí Frust." },
      "PIM":     { title:"PIM",      text:"Produktstammdaten als Quelle.",       impact:"Inkonsistent ‚Üí falsche Infos im Shop." },
      "DataLake":{ title:"Data Lake",text:"Zentrale Datenbasis.",               impact:"Garbage in ‚Üí Garbage out." }
    };

    const TASK_DURATION_MS = 4000;
    const DEMO_TASK_DURATION_MS = 3000;

    const TASK_BANK = [
      {
        icon:"üìû",
        title:"Anruf vom Kundenservice",
        prompt:"Kunde ist aufgebracht. Was machst du zuerst?",
        options:[
          {label:"Ticket anlegen", ok:true},
          {label:"Sp√§ter zur√ºckrufen", ok:false},
          {label:"Weiterleiten", ok:false}
        ]
      },
      {
        icon:"üì¶",
        title:"Versandproblem",
        prompt:"Lieferadresse passt nicht zum Kunden. Aktion?",
        options:[
          {label:"Adresse verifizieren", ok:true},
          {label:"Einfach schicken", ok:false},
          {label:"Stornieren", ok:false}
        ]
      },
      {
        icon:"üí¨",
        title:"R√ºckfrage Finance",
        prompt:"Zahlungsdaten unklar. Wie reagierst du?",
        options:[
          {label:"Stammdatensatz pr√ºfen", ok:true},
          {label:"Sch√§tzen & buchen", ok:false},
          {label:"Ignorieren", ok:false}
        ]
      }
    ];

    const IMPACTS_DUP = [
      { stars: 2, text: "Ich existiere doppelt ‚Äì Support findet meinen Vorgang nicht.", area:"Support", cost:[220, 800], score:-110 },
      { stars: 2, text: "Doppelte Rechnung ‚Äì bitte kl√§ren!", area:"Finance", cost:[260, 950], score:-130 },
      { stars: 1, text: "Zwei Kundenkonten ‚Äì Punkte & Historie sind weg.", area:"CRM", cost:[180, 650], score:-85 },
      { stars: 2, text: "Falsche Zuordnung wegen Dublette.", area:"Shop/WMS", cost:[240, 1000], score:-120 }
    ];

    const IMPACTS = [
      { stars: 1, text: "Bestellung nie angekommen.", area: "Versand",       cost: [350, 900],  score: -120 },
      { stars: 2, text: "Rechnung falsch ‚Äì muss ich wieder hinterherlaufen?", area:"Finance",   cost: [220, 700],  score: -90 },
      { stars: 1, text: "Adresse war korrekt ‚Äì warum an Nachbarn geliefert?", area:"CRM/Ship", cost: [280, 1100], score: -140 },
      { stars: 2, text: "Doppelter Kundenstamm: Support findet mich nicht.",  area:"Support",  cost: [180, 650],  score: -80 },
      { stars: 1, text: "Retouren-Chaos wegen falscher Artikelstammdaten.",   area:"Shop/WMS", cost: [300, 1300], score: -150 },
      { stars: 3, text: "Lieferung versp√§tet, Status stimmt nicht.",          area:"Tracking", cost: [120, 420],  score: -45 }
    ];

    const LEVELS = [
      // L1: no incidents by design (single system)
      { id:1, name:"First Date (Tutorial)", systems:1, records:10, baseErrorRate:0.012, duplicateRate:0.000, replRate:0.00, costPerBadPerSec:0.25, timeWeight:1.0, sessionLen:60.0, incidents:false },
      { id:2, name:"Offene Beziehung",     systems:3, records:18, baseErrorRate:0.020, duplicateRate:0.012, replRate:0.75, costPerBadPerSec:1.8, timeWeight:1.15, sessionLen:90.0, incidents:true  },
      { id:3, name:"Commitment Issues",    systems:6, records:28, baseErrorRate:0.028, duplicateRate:0.020, replRate:0.85, costPerBadPerSec:3.2, timeWeight:1.35, sessionLen:90.0, incidents:true  },
      { id:4, name:"Toxisch",              systems:9, records:40, baseErrorRate:0.034, duplicateRate:0.026, replRate:0.92, costPerBadPerSec:4.6, timeWeight:1.65, sessionLen:90.0, incidents:true  },
      { id:5, name:"True Love (MDM)",      systems:9, records:40, baseErrorRate:0.016, duplicateRate:0.006, replRate:0.62, costPerBadPerSec:1.0, timeWeight:0.95, forceMdm:true, sessionLen:90.0, incidents:true }
    ];

    class Record{
      constructor(x,y){
        this.x=x; this.y=y;
        this.vx=rnd(-18,18); this.vy=rnd(-18,18);
        this.r=11;
        this.state="good"; // good | bad | dupA | dupB
        this.originSys=0;  // stays here
        this.repTo=0;      // replicated up to system index
        this.localFixTo=-1; // local patch up to sys index (ghost fix), origin still wrong
        this.localMergeTo=-1; // local mapping/merge in downstream, origin still duplicated
        this.id = Math.random().toString(16).slice(2);
        this.link=null;
        this.jitter=rnd(0,1000);
      }
    }

    // =========================
    // State
    // =========================
    const game = {
      viewport:{w:0,h:0},
      dpr:1,
      lvlIndex:0,
      mdm:false,
      systems:[],
      records:[],
      metrics:{quality:100, errors:0, dups:0, fixes:0, cost:0, timeSpent:0, score:0},

      sessionOn:true,
      sessionLen:120.0,
      sessionLeft:120.0,
      sessionState:"live",

      demo:{ on:false, nextActionIn:1.0, autoRestartIn:2.2 },

      tutorial:{ active:false, step:0 },
      tutorialImpactDone:false,

      task:null,          // active minigame task
      taskUntil:0,
      taskRects:[],       // hitboxes for task options

      nextImpactIn:7.5,
      nextEventIn:7.0,

      systemPopup:{ active:false, x:0, y:0, data:null, until:0 },

      toastAt:0,
      help:{ seenGhostTip:false }
    };

    let baseline = { taken:false, mdmState:false, quality:0, cost:0, score:0 };
    function snapshotBaseline(){
      baseline = {
        taken:true,
        mdmState: game.mdm,
        quality: Math.round(game.metrics.quality),
        cost: Math.round(game.metrics.cost),
        score: Math.round(game.metrics.score)
      };
    }

    function toast(html, tag){
      const t = el("toast");
      t.innerHTML = html + (tag ? `<span class="tag">${tag}</span>` : "");
      t.classList.add("show");
      game.toastAt = now();
    }

    // =========================
    // Layout
    // =========================
    function resize(){
      const r = stage.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2.25, window.devicePixelRatio || 1));
      canvas.width = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      canvas.style.width = r.width + "px";
      canvas.style.height = r.height + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
      game.viewport.w = r.width;
      game.viewport.h = r.height;
      game.dpr = dpr;
    }
    window.addEventListener("resize", resize);

    function buildSystems(n){
      const W = game.viewport.w, H = game.viewport.h;
      const pad = 74;
      const xs=[];
      if(n===1) xs.push(W*0.5);
      else for(let i=0;i<n;i++) xs.push(lerp(pad, W-pad, i/(n-1)));

      const yBase = H*0.33;
      const yAmp  = Math.min(110, H*0.18);
      const baseR = clamp(Math.min(46, Math.max(34, W*0.055)), 34, 46);

      const labels = (SYSTEM_LABELS[game.lvlIndex] || []).slice(0,n);
      return xs.map((x,i)=>{
        const phase = (i/(Math.max(1,n-1))) * Math.PI * 1.2;
        const y = yBase + Math.sin(phase) * yAmp;
        return { x, y, r: baseR, idx:i, label: labels[i] || ("SYS "+(i+1)) };
      });
    }

    // =========================
    // Metrics
    // =========================
    function effectiveStateAtSys(r, sysIdx){
      // Downstream patches can mask symptoms, but don't clean origin truth.
      if(r.localFixTo >= sysIdx) return "good";
      if(r.localMergeTo >= sysIdx && (r.state==="dupA" || r.state==="dupB")) return "good";
      return r.state;
    }

    function computeQuality(){
      // quality should reflect "real world": upstream truth is what matters most, but patched late helps a bit
      let bad=0, dup=0, patched=0, mapped=0;
      for(const r of game.records){
        if(r.state==="bad") bad++;
        if(r.state==="dupA" || r.state==="dupB") dup++;
        if(r.localFixTo >= 2) patched++;
        if(r.localMergeTo >= 2) mapped++;
      }
      const total = game.records.length || 1;

      // base penalty from truth
      let q = 100 - (bad/total)*62 - (dup/total)*52;

      // small relief if many late local patches / dedupe mappings exist (still not great)
      q += (patched/total)*10;
      q += (mapped/total)*8;

      q = clamp(q, 0, 100);
      game.metrics.errors = bad;
      game.metrics.dups = Math.floor(dup/2);
      game.metrics.quality = q;
    }

    function replLabel(){
      const L = LEVELS[game.lvlIndex];
      const s = L.replRate * (game.mdm ? 0.45 : 1.0);
      if(s < 0.55) return "niedrig";
      if(s < 0.85) return "mittel";
      return "hoch";
    }

    function updateHUD(){
      computeQuality();
      const m = game.metrics;
      const q = m.quality;

      el("qVal").textContent = String(Math.round(q));
      const bar = el("qBar");
      bar.style.width = `${q}%`;
      bar.style.background = qualityColor(q);

      el("sysVal").textContent = String(LEVELS[game.lvlIndex].systems);
      el("recVal").textContent = String(LEVELS[game.lvlIndex].records);
      el("errVal").textContent = String(m.errors);
      el("dupVal").textContent = String(m.dups);
      el("fixVal").textContent = String(m.fixes);
      el("costVal").textContent = fmtEuro(m.cost);
      el("timeVal").textContent = m.timeSpent.toFixed(1);
      el("spreadVal").textContent = (LEVELS[game.lvlIndex].systems < 2) ? "‚Äî" : replLabel();

      el("scoreVal").textContent = String(Math.round(m.score));
      // Produktivit√§t: grob (weniger Tasks/Incidents + hohe Qualit√§t). Mit MDM typischerweise h√∂her.
      const baseProd = m.quality;
      const taskPenalty = game.task ? 18 : 0;
      const mdmBonus = game.mdm ? 10 : 0;
      const prod = clamp(baseProd - taskPenalty + mdmBonus, 0, 100);
      el("prodVal").textContent = String(Math.round(prod));
      const pb = el("prodBar");
      pb.style.width = `${prod}%`;
      pb.style.background = qualityColor(prod);
      if(game.sessionOn) el("timerLbl").textContent = `${Math.ceil(game.sessionLeft)}s`;
    }

    // =========================
    // Tutorial
    // =========================
    function tutorialStartIfLevel1(){
      const L = LEVELS[game.lvlIndex];
      if(L.id !== 1){ game.tutorial.active=false; return; }
      game.tutorial.active=true;
      game.tutorial.step=0;
      game.tutorialImpactDone=false;
      toast("Level 1: Du siehst nur den Ursprung. Folgen kommen sp√§ter.", "Tutorial");
    }

    function tutorialTick(){
      if(!game.tutorial.active) return;
      switch(game.tutorial.step){
        case 0:
          game.records.forEach((r,i)=>{ r.state=(i===0?"bad":"good"); r.link=null; r.repTo=0; r.localFixTo=-1; });
          toast("Tippe rot zum Fix am Ursprung.", "Tutorial");
          game.tutorial.step=1;
          break;
        case 1:
          if(game.metrics.errors===0){
            toast("Gut ‚úîÔ∏è Jetzt kommt echtes Leben: Unterbrechungen.", "Tutorial");
            game.tutorial.step=2;
          }
          break;
        case 2:
          if(!game.task){
            spawnTask(true);
            toast("Mini-Task: schnell entscheiden ‚Äì dann zur√ºck zur Bereinigung.", "Tutorial");
          }
          game.tutorial.step=3;
          break;
        case 3:
          if(!game.task){
            toast("Weiter mit Level 2: Replikation + sp√§te Kosten.", "Tutorial");
            game.tutorial.active=false;
          }
          break;
      }
    }

    // =========================
    // Tasks: Minigame over data
    // =========================
    function spawnTask(force=false){
      const L = LEVELS[game.lvlIndex];
      if(game.task) return;
      if(game.sessionOn && game.sessionState==="ended") return;

      // In Level 1: allow tutorial task. In others: random
      if(!force){
        // probability tuned for not-too-annoying
        const p = (game.mdm ? 0.035 : 0.055);
        if(Math.random() > p) return;
        // avoid spawning if chaos is already high
        if(game.metrics.quality < 35 && Math.random() < 0.6) return;
      }

      const t = TASK_BANK[(Math.random()*TASK_BANK.length)|0];
      // clone and shuffle options
      const opts = [...t.options].sort(()=>Math.random()-0.5);
      game.task = {
        icon:t.icon,
        title:t.title,
        prompt:t.prompt,
        options:opts,
        // position in canvas space
        x: rnd(game.viewport.w*0.32, game.viewport.w*0.68),
        y: rnd(game.viewport.h*0.48, game.viewport.h*0.78),
      };
      game.taskUntil = now() + (game.demo.on ? DEMO_TASK_DURATION_MS : TASK_DURATION_MS);
      game.taskRects = [];
    }

    function resolveTask(ok){
      if(!game.task) return;
      if(ok){
        game.metrics.score += 40;
        if(game.mdm && Math.random() < 0.35){
          toast(`üëç Sauberer Prozess ‚Äì MDM verhindert Folgefehler.`, "MDM");
        } else {
          toast(`Task erledigt ‚úîÔ∏é ‚Äî Fokus zur√ºck auf Stammdaten.`, "Task");
        }
      } else {
        // penalty: short burst of background decay / replication boost
        game.metrics.score -= 30;
        game.metrics.cost += 80 + (LEVELS[game.lvlIndex].systems*18);
        toast(`Task schief gelaufen ‚Äî Datenqualit√§t leidet im Hintergrund.`, "Task");
        // inject 1-2 new upstream errors to simulate distraction
        const n = 1 + (Math.random()<0.20 ? 1 : 0);
        for(let i=0;i<n;i++){
          const r = game.records.find(x=>x.state==="good" && x.repTo<=1);
          if(r) r.state="bad";
        }
      }
      game.task = null;
      game.taskRects = [];
      game.taskUntil = 0;
    }

    // =========================
    // Impacts / Incidents
    // =========================
    function triggerImpact(reasonTag){
      const damp = game.mdm ? 0.35 : 1.0;
      const imp = IMPACTS[(Math.random()*IMPACTsLen)|0];
      const spike = (imp.cost[0] + Math.random()*(imp.cost[1]-imp.cost[0])) * damp;

      game.metrics.cost += spike;
      game.metrics.score += Math.round(imp.score * damp);

      toast(`${stars(imp.stars)} <b>${imp.text}</b> <span class="tag">${imp.area}</span> <span class="tag">+${fmtEuro(spike)}</span>`, reasonTag || "Impact");
    }
    const IMPACTsLen = IMPACTS.length;

    function lateExposureSignal(){
      const L = LEVELS[game.lvlIndex];
      const last = Math.max(0, L.systems-1);
      const lateThreshold = Math.max(2, Math.floor(last * 0.7));

      let bad=0, dup=0;
      for(const r of game.records){
        if(r.repTo >= lateThreshold){
          // evaluate state AT late system (patched replicas count as good)
          const st = effectiveStateAtSys(r, lateThreshold);
          if(st==="bad") bad++;
          if(st==="dupA"||st==="dupB") dup++;
        }
      }
      return { badLate: bad, dupLate: dup, lateThreshold };
    }

    function maybePropagationEvent(dt){
      const L = LEVELS[game.lvlIndex];
      if(!L.incidents) return;
      if(L.systems < 2) return;
      if(game.sessionOn && game.sessionState!=="live") return;
      if(game.mdm && Math.random() < 0.88){
        // with MDM, downstream incidents are rare
        game.nextEventIn = Math.max(game.nextEventIn, 6.0);
        return;
      }

      game.nextEventIn -= dt;
      if(game.nextEventIn > 0) return;

      const { badLate, dupLate } = lateExposureSignal();
      if(badLate + dupLate === 0){
        game.nextEventIn = 4.0 + Math.random()*6.0;
        return;
      }

      const sev = clamp((badLate*1.0 + dupLate*1.2)/6.0, 0.3, 2.2);
      const baseSpike = 220 * sev * (1 + (L.systems/4));
      const spike = baseSpike * (game.mdm ? 0.35 : 1.0);

      game.metrics.cost += spike;
      game.metrics.score -= Math.round(spike * 0.15);

      const what = (Math.random()<0.5) ? "Rechnungslauf" : "Versand/CRM";
      toast(`‚ö†Ô∏è Incident in <b>${what}</b>: replizierte Fehler schlagen durch ‚Üí <b>${fmtEuro(spike)}</b> Extra-Kosten.`, "Incident");

      game.nextEventIn = 8.0 + Math.random()*8.0;
    }

    function maybeImpact(dt){
      const L = LEVELS[game.lvlIndex];
      if(!L.incidents) return;
      if(L.systems < 2) return;
      if(game.sessionOn && game.sessionState!=="live") return;
      if(game.mdm && Math.random() < 0.85){
        game.nextImpactIn = Math.max(game.nextImpactIn, 7.0);
        return;
      }

      game.nextImpactIn -= dt;
      if(game.nextImpactIn > 0) return;

      const { badLate, dupLate } = lateExposureSignal();
      const lateSignal = clamp((badLate*1.0 + dupLate*1.2) / 6.0, 0, 1);
      const taskBoost  = game.task ? 0.25 : 0.0;

      if(lateSignal > 0.12 || game.task){
        const p = clamp((0.16 + lateSignal*0.75 + taskBoost) * (game.mdm ? 0.25 : 1.0), 0, 0.95);
        if(Math.random() < p){
          const damp = game.mdm ? 0.35 : 1.0;
          const useDup = (dupLate > badLate) && (Math.random() < 0.75);
          const pool = useDup ? IMPACTS_DUP : IMPACTS;
          const imp = pool[(Math.random()*pool.length)|0];
          const spike = (imp.cost[0] + Math.random()*(imp.cost[1]-imp.cost[0])) * damp;
          game.metrics.cost += spike;
          game.metrics.score += Math.round(imp.score * damp);
          toast(`${stars(imp.stars)} <b>${imp.text}</b> <span class="tag">${imp.area}</span> <span class="tag">+${fmtEuro(spike)}</span>`, game.task ? "Task‚ÜíImpact" : "Late‚ÜíImpact");
        }
      }

      game.nextImpactIn = (game.mdm ? 12.0 : 9.5) + Math.random() * (game.mdm ? 10 : 8);
    }

    // =========================
    // Simulation
    // =========================
    function spreadTick(dt){
      const L = LEVELS[game.lvlIndex];

      // spawn minigame tasks (even in level 1, but lower)
      if(!game.task && (L.id===1 ? Math.random()<dt*0.04 : true)) spawnTask(false);

      // task timeouts
      if(game.task && now() > game.taskUntil){
        resolveTask(false);
      }

      // Distraction factor: while task is active, more decay + more replication
      const taskFactor = game.task ? 1.28 : 1.0;

      // "Entstehung" stark fr√ºh, Replikation √ºberall
      const errRate  = L.baseErrorRate * (game.mdm ? 0.08 : 1.0) * taskFactor;
      const dupRate  = L.duplicateRate * (game.mdm ? 0.05 : 1.0) * taskFactor;
      const replRate = L.replRate      * (game.mdm ? 0.45 : 1.0) * (game.task ? 1.12 : 1.0);

      // With MDM: errors are prevented/validated at the source, so they don't spread into usage systems.
      const mdmPreventsSpread = !!game.mdm;

      for(const r of game.records){
        const early = (r.repTo <= 1);

        // Replikation nach hinten (keine neue Entstehung dort)
        const advanceProb = replRate * 0.16 * dt;
        if(r.repTo < game.systems.length-1 && Math.random() < advanceProb){
          if(mdmPreventsSpread && r.state !== "good"){
            // validation blocks propagation of faulty data
          } else {
            r.repTo++;
          }
        }

        // New errors mainly early
        if(r.state==="good"){
          const pErr = early ? errRate : errRate * 0.12;
          if(Math.random() < pErr * dt) r.state="bad";
        }

        // Duplicates mainly early
        if(!mdmPreventsSpread && r.state==="good" && early && L.systems>=2 && Math.random() < dupRate * dt){
          const a = r;
          const b = new Record(a.x + rnd(-22,22), a.y + rnd(-22,22));
          b.originSys = a.originSys;
          b.repTo = a.repTo;
          a.state="dupA"; b.state="dupB";
          a.link=b.id; b.link=a.id;
          game.records.push(b);
        }

        if(!game.mdm){
          // local patches/mappings are fragile
          if(r.localFixTo >= 2){
            const frac = r.localFixTo / Math.max(1, (game.systems.length-1));
            const relapse = (0.010 + frac*0.020) * dt * taskFactor;
            if(Math.random() < relapse){
              r.localFixTo = -1;
        r.localMergeTo = -1;
              if(Math.random() < 0.15) toast("Lokalfix ist wieder aufgetaucht ‚Äì Ursprung war nie sauber.", "Folgesystem");
            }
          }
          if(r.localMergeTo >= 2){
            const frac = r.localMergeTo / Math.max(1, (game.systems.length-1));
            const relapse = (0.008 + frac*0.016) * dt * taskFactor;
            if(Math.random() < relapse){
              r.localMergeTo = -1;
              if(Math.random() < 0.12) toast("Downstream-Mapping ist wieder inkonsistent ‚Äì Dublette am Ursprung bleibt.", "Folgesystem");
            }
          }
        }
      }

      // Upstream contamination (copy/paste/import)
      const infectors = game.records.filter(r => r.state!=="good");
      if(!mdmPreventsSpread && infectors.length){
        const attempts = Math.min(40, infectors.length);
        for(let i=0;i<attempts;i++){
          const src = infectors[(Math.random()*infectors.length)|0];
          const cand = game.records[(Math.random()*game.records.length)|0];
          if(!cand || cand.state!=="good") continue;
          if(cand.repTo > 1) continue; // only early "creation"

          const dx = cand.x - src.x, dy = cand.y - src.y;
          const dist2 = dx*dx + dy*dy;
          const radius = 120;
          const p = 0.06 * dt * (dist2 < radius*radius ? 0.9 : 0.2) * (game.mdm ? 0.45 : 1.0) * taskFactor;
          if(Math.random() < p) cand.state="bad";
        }
      }

      computeQuality();

      // Cost: base from existing bad/dup; reduced if patched late; amplified by how far unpatched error replicated
      let lateWeightSum = 0;
      for(const r of game.records){
        // evaluate "effective" error per system position
        if(r.state==="good") continue;

        // if everything up to repTo is patched, late cost is reduced, but still some admin overhead
        const patchedAll = (r.localFixTo >= r.repTo && r.repTo >= 2)
                       || ((r.state==="dupA"||r.state==="dupB") && r.localMergeTo >= r.repTo && r.repTo >= 2);
        const baseAdmin = patchedAll ? 0.25 : 0.0;

        const frac = (r.repTo / Math.max(1, (game.systems.length-1)));
        const weight = (patchedAll ? (0.45 + frac*0.55) : (0.6 + frac*1.6)) + baseAdmin;
        lateWeightSum += weight;
      }

      game.metrics.cost += lateWeightSum * L.costPerBadPerSec * dt;

      // Score: reward quality & time, small mdm bonus
      game.metrics.score += Math.round((game.metrics.quality - 70) * 0.02);
      game.metrics.score += (game.mdm ? 1 : 0);
      game.metrics.timeSpent += dt * L.timeWeight;

      maybePropagationEvent(dt);
      maybeImpact(dt);

      if(game.sessionOn && game.sessionState==="live"){
        game.sessionLeft = Math.max(0, game.sessionLeft - dt);
        if(game.sessionLeft <= 0){
          game.sessionState = "ended";
          if(!baseline.taken) snapshotBaseline();
        }
      }
    }

    // =========================
    // Movement (masters stay near origin)
    // + "bad floats up" to be reachable
    // =========================
    function step(dt){
      const origin = game.systems[0] || {x:game.viewport.w/2, y:game.viewport.h/2};
      const topBand = 46;

      for(const r of game.records){
        const t = (now() + r.jitter) * 0.001;
        const ox = Math.cos(t*1.5) * 48;
        const oy = Math.sin(t*1.2) * 38;

        r.vx += rnd(-10,10) * dt;
        r.vy += rnd(-10,10) * dt;

        const ax = (origin.x+ox - r.x) * 1.0;
        const ay = (origin.y+oy - r.y) * 1.0;
        r.vx += ax * dt;
        r.vy += ay * dt;

        if(r.state==="bad") r.vy -= 42 * dt;

        r.vx *= (1 - 0.78*dt);
        r.vy *= (1 - 0.78*dt);

        r.x += r.vx * dt;
        r.y += r.vy * dt;

        const pad = 18;
        if(r.x < pad){ r.x=pad; r.vx*=-0.6; }
        if(r.y < pad){ r.y=pad; r.vy*=-0.6; }
        if(r.x > game.viewport.w-pad){ r.x=game.viewport.w-pad; r.vx*=-0.6; }
        if(r.y > game.viewport.h-pad){ r.y=game.viewport.h-pad; r.vy*=-0.6; }

        if(r.state==="bad" && r.y < topBand) r.y = topBand;
      }
    }

    // =========================
    // Drawing helpers
    // =========================
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }
    function drawHeart(x,y,s,stroke){
      ctx.save();
      ctx.strokeStyle = stroke; ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.bezierCurveTo(x - s, y - s, x - 2*s, y + s/2, x, y + 2*s);
      ctx.bezierCurveTo(x + 2*s, y + s/2, x + s, y - s, x, y);
      ctx.stroke();
      ctx.restore();
    }
    function wrapText(text, x, y, maxWidth, lineHeight){
      const words = String(text).split(" ");
      let line="", yy=y;
      ctx.textAlign="left"; ctx.textBaseline="middle";
      for(let n=0;n<words.length;n++){
        const testLine = line + words[n] + " ";
        if(ctx.measureText(testLine).width > maxWidth && n>0){
          ctx.fillText(line, x, yy);
          line = words[n] + " ";
          yy += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, yy);
    }

    // =========================
    // End card / share
    // =========================
    function drawEndCard(){
      const W=game.viewport.w, H=game.viewport.h;
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,.45)";
      ctx.fillRect(0,0,W,H);

      const pw = Math.min(560, W-26), ph=260;
      const px=(W-pw)/2, py=(H-ph)/2;

      ctx.fillStyle="rgba(17,24,39,.92)";
      ctx.strokeStyle="rgba(255,255,255,.14)";
      ctx.lineWidth=1;
      ctx.beginPath(); roundRect(ctx, px, py, pw, ph, 20); ctx.fill(); ctx.stroke();

      ctx.fillStyle="rgba(255,255,255,.92)";
      ctx.font="950 20px system-ui";
      ctx.textAlign="left"; ctx.textBaseline="middle";
      ctx.fillText("Love your Data üíô ‚Äì Session Ergebnis", px+18, py+34);

      ctx.fillStyle="rgba(156,163,175,.95)";
      ctx.font="700 13px system-ui";
      ctx.fillText(el("lvlLbl").textContent, px+18, py+60);

      ctx.fillStyle=getCSS("--mdm-blue");
      ctx.font="950 34px system-ui";
      ctx.fillText(`Score ${Math.round(game.metrics.score)}`, px+18, py+102);

      const q = Math.round(game.metrics.quality);
      ctx.fillStyle="rgba(255,255,255,.86)";
      ctx.font="850 14px system-ui";
      ctx.fillText(`Qualit√§t: ${q}%`, px+18, py+132);
      ctx.fillText(`Kosten: ${fmtEuro(game.metrics.cost)}`, px+180, py+132);

      ctx.strokeStyle="rgba(255,255,255,.10)";
      ctx.beginPath(); ctx.moveTo(px+18, py+150); ctx.lineTo(px+pw-18, py+150); ctx.stroke();

      if(baseline.taken){
        const cur = { quality: Math.round(game.metrics.quality), cost: Math.round(game.metrics.cost), score: Math.round(game.metrics.score) };
        const aLabel = baseline.mdmState ? "Mit MDM (Baseline)" : "Ohne MDM (Baseline)";
        const bLabel = game.mdm ? "Mit MDM (Jetzt)" : "Ohne MDM (Jetzt)";

        ctx.font="700 12.5px system-ui";
        ctx.fillStyle="rgba(156,163,175,.95)";
        ctx.fillText(`${aLabel}: Q ${baseline.quality}% ‚Ä¢ ${fmtEuro(baseline.cost)} ‚Ä¢ S ${baseline.score}`, px+18, py+176);

        ctx.fillStyle=getCSS("--mdm-blue");
        ctx.fillText(`${bLabel}: Q ${cur.quality}% ‚Ä¢ ${fmtEuro(cur.cost)} ‚Ä¢ S ${cur.score}`, px+18, py+198);

        const dq = cur.quality - baseline.quality;
        const dc = baseline.cost - cur.cost;
        const ds = cur.score - baseline.score;

        ctx.fillStyle="rgba(255,255,255,.86)";
        ctx.font="900 13px system-ui";
        ctx.fillText(`Œî Qualit√§t ${dq>=0?"+":""}${dq}%   Œî Kosten ${dc>=0?"-":"+"}${fmtEuro(Math.abs(dc))}   Œî Score ${ds>=0?"+":""}${ds}`, px+18, py+226);
      } else {
        ctx.fillStyle="rgba(156,163,175,.95)";
        ctx.font="700 12.5px system-ui";
        ctx.fillText("Tipp: zweite Runde starten f√ºr Vergleich (mit/ohne MDM).", px+18, py+188);
      }

      ctx.fillStyle="rgba(156,163,175,.9)";
      ctx.font="700 12px system-ui";
      ctx.fillText("Share: Button oben ‚Ä¢ Reset: neue Runde", px+18, py+248);
      ctx.restore();
    }

    async function shareCanvasPNG(){
      const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/png", 1.0));
      if(!blob){ toast("Export fehlgeschlagen.", "Share"); return; }
      const file = new File([blob], "love-your-data.png", { type:"image/png" });

      if(navigator.canShare && navigator.canShare({ files:[file] })){
        try{
          await navigator.share({ files:[file], title:"Love your Data ‚Äì Ergebnis", text:"Stammdatenqualit√§t spielerisch erkl√§rt." });
          toast("Geteilt ‚úîÔ∏è", "Share");
          return;
        }catch(e){}
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href=url; a.download="love-your-data.png";
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
      toast("PNG gespeichert ‚úîÔ∏è", "Share");
    }

    // =========================
    // Rendering
    // =========================
    function draw(){
      const W=game.viewport.w, H=game.viewport.h;
      ctx.clearRect(0,0,W,H);

      // subtle grid
      ctx.save();
      ctx.globalAlpha=0.08;
      ctx.strokeStyle="white";
      ctx.lineWidth=1;
      const stepG=38;
      for(let x=0;x<W;x+=stepG){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for(let y=0;y<H;y+=stepG){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
      ctx.restore();

      // connections (system chain)
      ctx.save();
      ctx.lineWidth=3;
      for(let i=0;i<game.systems.length;i++){
        const a=game.systems[i];
        if(i<game.systems.length-1){
          const b=game.systems[i+1];
          ctx.strokeStyle="rgba(255,255,255,.14)";
          ctx.beginPath();
          ctx.moveTo(a.x,a.y);
          ctx.quadraticCurveTo((a.x+b.x)/2, (a.y+b.y)/2 - 40, b.x, b.y);
          ctx.stroke();
          drawHeart(lerp(a.x,b.x,0.5), lerp(a.y,b.y,0.5)-22, 7, "rgba(255,255,255,.14)");
        }
      }
      ctx.restore();

      // systems
      const mdmBlue = getCSS("--mdm-blue");
      for(const s of game.systems){
        ctx.save();
        ctx.fillStyle="rgba(255,255,255,.06)";
        ctx.strokeStyle="rgba(255,255,255,.18)";
        ctx.lineWidth=2.2;
        ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); ctx.stroke();

        if(game.mdm){
          ctx.globalAlpha=0.18;
          ctx.strokeStyle=mdmBlue;
          ctx.lineWidth=3;
          ctx.beginPath(); ctx.arc(s.x,s.y,s.r+12,0,Math.PI*2); ctx.stroke();
          ctx.globalAlpha=1;
        }

        ctx.globalAlpha=0.92;
        ctx.fillStyle="rgba(255,255,255,.86)";
        ctx.font="900 13px system-ui";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(s.label, s.x, s.y-0.5);

        ctx.globalAlpha=0.7;
        ctx.font="800 10.5px system-ui";
        const tag = (s.idx<=1) ? "Quelle" : "Nutzung";
        ctx.fillText(tag, s.x, s.y+18);

        ctx.restore();
      }

      // draw replica ghosts first + store hit hints implicitly via deterministic offsets
      ctx.save();
      for(const r of game.records){
        if(r.repTo <= 0) continue;

        for(let i=1;i<=r.repTo;i++){
          const s = game.systems[i];
          if(!s) continue;

          const st = effectiveStateAtSys(r, i);
          const col = (st==="good") ? "rgba(34,197,94,.22)"
                    : (st==="bad")  ? "rgba(239,68,68,.28)"
                    :                "rgba(245,158,11,.26)";

          const t = (r.jitter + i*777) * 0.001;
          const ox = Math.cos(t*1.3) * 14;
          const oy = Math.sin(t*1.1) * 10;

          // if it is a local patch/mapping, show a tiny mark
          const patched = (r.localFixTo >= i && i>=2);
          const mapped  = ((r.state==="dupA"||r.state==="dupB") && r.localMergeTo >= i && i>=2);

          ctx.fillStyle = col;
          const rr = (patched || mapped) ? 5.0 : 4.2;
          ctx.beginPath();
          ctx.arc(s.x+ox, s.y+oy, rr, 0, Math.PI*2);
          ctx.fill();

          if(patched){
            ctx.strokeStyle="rgba(255,255,255,.20)";
            ctx.lineWidth=1;
            ctx.beginPath();
            ctx.moveTo(s.x+ox-3.0, s.y+oy);
            ctx.lineTo(s.x+ox+3.0, s.y+oy);
            ctx.stroke();
          }
          if(mapped){
            ctx.strokeStyle="rgba(255,255,255,.22)";
            ctx.lineWidth=1;
            ctx.beginPath();
            ctx.arc(s.x+ox, s.y+oy, 2.2, 0, Math.PI*2);
            ctx.stroke();
          }
        }
      }
      ctx.restore();

      // render order: good -> dup -> bad (bad last)
      const order = (st)=> (st==="bad"? 2 : (st==="dupA"||st==="dupB") ? 1 : 0);
      const recs = [...game.records].sort((a,b)=>order(a.state)-order(b.state));

      for(const r of recs){
        const col = (r.state==="good") ? "rgba(34,197,94,1)"
                  : (r.state==="bad")  ? "rgba(239,68,68,1)"
                  :                      "rgba(245,158,11,1)";

        // glow
        ctx.save();
        ctx.globalAlpha = (r.state==="good") ? 0.12 : 0.20;
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(r.x,r.y,r.r+8,0,Math.PI*2); ctx.fill();
        ctx.restore();

        // body
        ctx.save();
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.fill();

        ctx.fillStyle="rgba(0,0,0,.45)";
        ctx.font="900 12px system-ui";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        let t="‚úì"; if(r.state==="bad") t="!"; if(r.state==="dupA"||r.state==="dupB") t="‚âã";
        ctx.fillText(t, r.x, r.y+0.5);
        ctx.restore();

        // dup link
        if((r.state==="dupA"||r.state==="dupB") && r.link){
          const other = game.records.find(x=>x.id===r.link);
          if(other){
            ctx.save();
            ctx.strokeStyle="rgba(245,158,11,.22)";
            ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(r.x,r.y); ctx.lineTo(other.x,other.y); ctx.stroke();
            ctx.restore();
          }
        }
      }

      // Task minigame card (on top of data)
      if(game.task && (game.sessionOn ? game.sessionState==="live" : true)){
        const t = game.task;
        const pad=12;
        const w = Math.min(360, W-30);
        const h = 148;
        const x = clamp(t.x - w/2, 15, W-w-15);
        const y = clamp(t.y - h/2, 70, H-h-20);

        ctx.save();
        // card
        ctx.fillStyle="rgba(17,24,39,.92)";
        ctx.strokeStyle="rgba(255,255,255,.16)";
        ctx.lineWidth=1;
        ctx.beginPath(); roundRect(ctx, x, y, w, h, 16); ctx.fill(); ctx.stroke();

        // timer bar
        const frac = clamp((game.taskUntil - now()) / (game.demo.on ? DEMO_TASK_DURATION_MS : TASK_DURATION_MS), 0, 1);
        ctx.fillStyle="rgba(255,255,255,.08)";
        ctx.beginPath(); roundRect(ctx, x+pad, y+10, w-2*pad, 8, 6); ctx.fill();
        ctx.fillStyle=frac>0.34 ? "rgba(34,197,94,.75)" : "rgba(239,68,68,.75)";
        ctx.beginPath(); roundRect(ctx, x+pad, y+10, (w-2*pad)*frac, 8, 6); ctx.fill();

        ctx.fillStyle="rgba(255,255,255,.92)";
        ctx.font="900 14px system-ui";
        ctx.textAlign="left"; ctx.textBaseline="middle";
        ctx.fillText(`${t.icon} ${t.title}`, x+pad, y+34);

        ctx.fillStyle="rgba(229,231,235,.88)";
        ctx.font="650 13px system-ui";
        wrapText(t.prompt, x+pad, y+58, w-2*pad, 16);

        // options
        game.taskRects = [];
        const oy = y + 92;
        const btnW = (w-2*pad-12) / 3;
        for(let i=0;i<3;i++){
          const opt = t.options[i];
          const bx = x+pad + i*(btnW+6);
          const by = oy;
          const bw = btnW;
          const bh = 40;

          ctx.fillStyle="rgba(255,255,255,.06)";
          ctx.strokeStyle="rgba(255,255,255,.14)";
          ctx.lineWidth=1;
          ctx.beginPath(); roundRect(ctx, bx, by, bw, bh, 12); ctx.fill(); ctx.stroke();

          ctx.fillStyle="rgba(255,255,255,.90)";
          ctx.font="800 12px system-ui";
          ctx.textAlign="center"; ctx.textBaseline="middle";
          wrapText(opt.label, bx+10, by+bh/2, bw-20, 14);

          game.taskRects.push({x:bx,y:by,w:bw,h:bh, ok:opt.ok});
        }
        ctx.restore();
      }

      // quality badge
      const q=game.metrics.quality;
      ctx.save();
      ctx.globalAlpha=0.92;
      ctx.fillStyle="rgba(17,24,39,.55)";
      ctx.strokeStyle="rgba(255,255,255,.10)";
      ctx.lineWidth=1;
      const bw=168,bh=44;
      ctx.beginPath(); roundRect(ctx, W-bw-10, 10, bw, bh, 14); ctx.fill(); ctx.stroke();
      ctx.fillStyle=qualityColor(q);
      ctx.font="950 16px system-ui";
      ctx.textAlign="left"; ctx.textBaseline="middle";
      ctx.fillText(`Qualit√§t: ${Math.round(q)}%`, W-bw, 10+bh/2);
      ctx.restore();

      // system popup
      if(game.systemPopup.active && game.systemPopup.data){
        const {title,text,impact} = game.systemPopup.data;
        ctx.save();
        ctx.globalAlpha=0.95;
        ctx.fillStyle="rgba(17,24,39,.92)";
        ctx.strokeStyle="rgba(255,255,255,.14)";
        ctx.lineWidth=1;

        const w=Math.min(360, W-40), h=150;
        const x=clamp(game.systemPopup.x - w/2, 20, W-w-20);
        const y=clamp(game.systemPopup.y + 40, 20, H-h-20);

        ctx.beginPath(); roundRect(ctx,x,y,w,h,14); ctx.fill(); ctx.stroke();

        ctx.fillStyle="white";
        ctx.font="900 14px system-ui";
        ctx.textAlign="left"; ctx.textBaseline="middle";
        ctx.fillText(title, x+14, y+24);

        ctx.fillStyle="rgba(229,231,235,.9)";
        ctx.font="650 13px system-ui";
        ctx.fillText(text, x+14, y+50);

        ctx.fillStyle="rgba(239,68,68,.92)";
        ctx.font="800 12.5px system-ui";
        ctx.fillText("Folge:", x+14, y+78);

        ctx.fillStyle="rgba(229,231,235,.85)";
        ctx.font="700 12.5px system-ui";
        wrapText(impact, x+64, y+78, w-78, 15);

        if(game.mdm){
          ctx.fillStyle=mdmBlue;
          ctx.font="800 12.5px system-ui";
          ctx.fillText("MDM stoppt fr√ºh (Validierung + Golden Record).", x+14, y+128);
        }
        ctx.restore();
      }

      if(game.sessionOn && game.sessionState==="ended") drawEndCard();
    }

    // =========================
    // Picking
    // =========================
    function getPos(evt){
      const r = canvas.getBoundingClientRect();
      if(evt.touches && evt.touches[0]) return {x: evt.touches[0].clientX - r.left, y: evt.touches[0].clientY - r.top};
      if(evt.changedTouches && evt.changedTouches[0]) return {x: evt.changedTouches[0].clientX - r.left, y: evt.changedTouches[0].clientY - r.top};
      return {x: evt.clientX - r.left, y: evt.clientY - r.top};
    }

    function hitTaskOption(p){
      if(!game.task || !game.taskRects.length) return null;
      for(const r of game.taskRects){
        if(p.x>=r.x && p.x<=r.x+r.w && p.y>=r.y && p.y<=r.y+r.h) return r;
      }
      return null;
    }

    function findRecordAt(p){
      let best=null, bestD=1e9;
      for(const r of game.records){
        const dx=r.x-p.x, dy=r.y-p.y;
        const d=Math.sqrt(dx*dx+dy*dy);
        const extra = (r.state==="bad") ? 10 : 0; // easier to hit bad
        if(d < r.r + 22 + extra && d < bestD){ bestD=d; best=r; }
      }
      return best;
    }

    function findSystemAt(p){
      for(const s of game.systems){
        const dx=p.x-s.x, dy=p.y-s.y;
        const d=Math.sqrt(dx*dx+dy*dy);
        if(d < s.r + 16) return s;
      }
      return null;
    }

    function findReplicaAt(p){
      // find nearest ghost dot; returns {record, sysIdx} or null
      let best=null, bestD=1e9;
      for(const r of game.records){
        if(r.repTo <= 0) continue;
        for(let i=1;i<=r.repTo;i++){
          const s = game.systems[i];
          if(!s) continue;
          const t = (r.jitter + i*777) * 0.001;
          const ox = Math.cos(t*1.3) * 14;
          const oy = Math.sin(t*1.1) * 10;
          const gx = s.x+ox, gy=s.y+oy;
          const dx=gx-p.x, dy=gy-p.y;
          const d=Math.sqrt(dx*dx+dy*dy);
          const hitR = 12; // easy to tap
          if(d < hitR && d < bestD){
            bestD=d;
            best={record:r, sysIdx:i, gx, gy};
          }
        }
      }
      return best;
    }

    // =========================
    // Actions
    // =========================
    function fixOrigin(r){
      if(!r) return;
      if(game.sessionOn && game.sessionState!=="live") return;

      if(r.state==="bad"){
        r.state="good";
        r.localFixTo=-1; // origin fix makes patches unnecessary
        r.localMergeTo=-1;
        r.link=null;
        game.metrics.fixes++;
        game.metrics.score += 40;
        toast("Fix ‚úîÔ∏é ‚Äî Ursprung bereinigt (wirkt in allen Systemen).", "Ursprung");
      } else if(r.state==="dupA" || r.state==="dupB"){
        toast("Orange = Dublette. Long-Press = Merge (Golden Record).", "Dubletten");
      } else {
        toast("Gr√ºn = sauber.", "OK");
      }
    }

    function localFixReplica(r, sysIdx){
      if(!r) return;
      if(game.sessionOn && game.sessionState!=="live") return;
      if(sysIdx < 2) return; // early fix should happen at origin
      if(r.state==="good") return;

      if(!game.help.seenGhostTip){
        game.help.seenGhostTip = true;
        toast("Replikat-Tap = Downstream-Fix: teuer, symptomatisch, kann zur√ºckkommen.", "Tipp");
      }

      const isDup = (r.state==="dupA" || r.state==="dupB");

      const base = isDup ? 210 : 160;
      const per  = isDup ? 180 : 160;
      const spike = base + (sysIdx-1)*per * (game.mdm ? 0.65 : 1.0);

      if(isDup){
        r.localMergeTo = Math.max(r.localMergeTo, sysIdx);
        game.metrics.fixes++;
        game.metrics.cost += spike;
        game.metrics.score -= Math.round(34 + sysIdx*9);
        toast(`üîó Downstream-Mapping in <b>${game.systems[sysIdx]?.label || ("SYS "+(sysIdx+1))}</b> ‚Äî Dublette am Ursprung bleibt <span class="tag">+${fmtEuro(spike)}</span>`, "Folgesystem");
      } else {
        r.localFixTo = Math.max(r.localFixTo, sysIdx);
        game.metrics.fixes++;
        game.metrics.cost += spike;
        game.metrics.score -= Math.round(28 + sysIdx*8);
        toast(`ü©π Lokalfix in <b>${game.systems[sysIdx]?.label || ("SYS "+(sysIdx+1))}</b> ‚Äî teuer, Ursprung bleibt falsch <span class="tag">+${fmtEuro(spike)}</span>`, "Folgesystem");
      }
    }

    function mergeDupPair(r){
      if(!r) return false;
      if(game.sessionOn && game.sessionState!=="live") return false;
      if(!(r.state==="dupA" || r.state==="dupB") || !r.link) return false;

      const otherIndex = game.records.findIndex(x=>x.id===r.link);
      if(otherIndex < 0) return false;
      const other = game.records[otherIndex];

      r.x = (r.x + other.x)/2;
      r.y = (r.y + other.y)/2;

      r.state="good";
      r.link=null;
      r.localFixTo=-1;
      r.localMergeTo=-1;
      game.records.splice(otherIndex,1);

      game.metrics.fixes += 2;
      game.metrics.score += 65;
      toast("Merge üíô ‚Äî Dublette bereinigt (Golden Record).", "Merge");
      return true;
    }


    function healAllWithMdm(){
      if(!game.mdm) return;
      if(game.sessionOn && game.sessionState!=="live") return;

      // Merge duplicate pairs safely
      const done = new Set();
      for(const r of [...game.records]){
        if((r.state==="dupA" || r.state==="dupB") && r.link && !done.has(r.id) && !done.has(r.link)){
          done.add(r.id); done.add(r.link);
          mergeDupPair(r);
        }
      }

      // Fix remaining bad records
      let fixed=0;
      for(const r of game.records){
        if(r.state==="bad"){ r.state="good"; fixed++; }
        r.localFixTo = -1;
        r.localMergeTo = -1;
      }

      const bonus = 80 + fixed*8;
      game.metrics.score += bonus;
      toast(`‚úÖ MDM-Validierung: ${fixed} Fehler automatisch bereinigt.`, "MDM");
    }

    function openSystemPopup(sys){
      const info = SYSTEM_INFO[sys.label];
      if(!info) return;
      game.systemPopup.active=true;
      game.systemPopup.x=sys.x;
      game.systemPopup.y=sys.y;
      game.systemPopup.data=info;
      game.systemPopup.until=now()+4500;
      toast(`${info.title}: ${info.text}`, "System");
    }

    // =========================
    // Input: context-based long press (no conflicts)
    // =========================
    let longPressTimer=null;
    let downAt=0;
    let pressContext=null; // "record" | "system" | "replica" | "task" | null
    let pressTarget=null;

    function onDown(evt){
      evt.preventDefault?.();
      if(game.sessionOn && game.sessionState!=="live") return;

      const p = getPos(evt);
      downAt = now();

      // 1) Task option tap has priority
      const opt = hitTaskOption(p);
      if(opt){
        pressContext="task";
        pressTarget=opt;
        // resolve immediately on down for snappy feel
        resolveTask(!!opt.ok);
        return;
      }

      // 2) Replica tap: allow local fixes
      const rep = findReplicaAt(p);
      if(rep){
        pressContext="replica";
        pressTarget=rep;
      } else {
        // 3) Record > system
        const rec = findRecordAt(p);
        if(rec){
          pressContext="record";
          pressTarget=rec;
        } else {
          const sys = findSystemAt(p);
          if(sys){
            pressContext="system";
            pressTarget=sys;
          } else {
            pressContext=null;
            pressTarget=null;
          }
        }
      }

      clearTimeout(longPressTimer);
      longPressTimer = setTimeout(()=>{
        if(pressContext==="record"){
          if(pressTarget && (pressTarget.state==="dupA"||pressTarget.state==="dupB")) mergeDupPair(pressTarget);
        } else if(pressContext==="system"){
          if(pressTarget) openSystemPopup(pressTarget);
        }
      }, 420);
    }

    function onUp(evt){
      evt.preventDefault?.();

      // close popup with any tap
      if(game.systemPopup.active){
        game.systemPopup.active=false;
        game.systemPopup.data=null;
        return;
      }

      if(game.sessionOn && game.sessionState!=="live") return;

      clearTimeout(longPressTimer);
      const held = now() - downAt;

      // Tap behavior
      if(held < 380){
        if(pressContext==="record" && pressTarget){
          fixOrigin(pressTarget);
        } else if(pressContext==="replica" && pressTarget){
          localFixReplica(pressTarget.record, pressTarget.sysIdx);
        }
      }

      pressContext=null;
      pressTarget=null;
    }

    canvas.addEventListener("touchstart", onDown, {passive:false});
    canvas.addEventListener("touchend",   onUp,   {passive:false});
    canvas.addEventListener("mousedown",  onDown);
    window.addEventListener("mouseup",    onUp);

    // =========================
    // UI toggles
    // =========================
    function syncMdmUI(){
      const L = LEVELS[game.lvlIndex];
      const forced = !!L.forceMdm;
      const btn = el("btnMdm");
      const pill = el("mdmPill");

      if(game.mdm){
        btn.textContent = forced ? "MDM: On (locked)" : "MDM: On";
        pill.style.display="inline-flex";
      } else {
        btn.textContent = "MDM: Off";
        pill.style.display="none";
      }
      const heal = el("btnHeal");
      if(heal){
        heal.style.display = game.mdm ? "inline-flex" : "none";
        heal.disabled = !game.mdm;
      }
      btn.disabled = forced;
      btn.style.opacity = forced ? 0.6 : 1;
    }
    function syncSessionUI(){
      el("btnSession").textContent = `Session: ${game.sessionOn ? "On" : "Off"}`;
      el("timerPill").style.display = game.sessionOn ? "inline-flex" : "none";
    }
    function syncDemoUI(){
      el("btnDemo").textContent = `Demo: ${game.demo.on ? "On" : "Off"}`;
    }

    // =========================
    // Demo mode
    // =========================
    function runDemo(dt){
      if(!game.demo.on) return;

      if(game.sessionOn && game.sessionState==="ended"){
        game.demo.autoRestartIn -= dt;
        if(game.demo.autoRestartIn <= 0){
          const L = LEVELS[game.lvlIndex];
          if(!L.forceMdm) game.mdm = !game.mdm;
          syncMdmUI();
          initLevel(game.lvlIndex);

          game.demo.autoRestartIn = 2.2 + Math.random()*1.5;
          game.demo.nextActionIn  = 1.2 + Math.random()*0.8;
        }
        return;
      }

      // Resolve tasks with a short readable delay (demo should be legible)
      if(game.task){
        game.demo.nextActionIn -= dt;
        if(game.demo.nextActionIn > 0) return;
        game.demo.nextActionIn = 1.0 + Math.random()*0.7;

        if(Math.random() < 0.82){ resolveTask(true); } else { resolveTask(false); }
        return;
      }

      game.demo.nextActionIn -= dt;
      if(game.demo.nextActionIn > 0) return;
      game.demo.nextActionIn = 0.55 + Math.random()*0.9;

      const bad = game.records.find(r=>r.state==="bad");
      if(bad){ fixOrigin(bad); return; }

      // sometimes show local fix
      const badLate = game.records.find(r=>r.state==="bad" && r.repTo>=3 && r.localFixTo<3);
      if(badLate){
        localFixReplica(badLate, 3);
        return;
      }

      const dup = game.records.find(r=>(r.state==="dupA"||r.state==="dupB"));
      if(dup){ mergeDupPair(dup); return; }
    }

    // =========================
    // Level init
    // =========================
    function initLevel(idx){
      game.lvlIndex = clamp(idx, 0, LEVELS.length-1);
      const L = LEVELS[game.lvlIndex];
      if(L.forceMdm) game.mdm = true;

      game.metrics = {quality:100, errors:0, dups:0, fixes:0, cost:0, timeSpent:0, score:0};
      game.records = [];
      game.systems = buildSystems(L.systems);

      const origin = game.systems[0] || {x:game.viewport.w/2, y:game.viewport.h/2};
      for(let i=0;i<L.records;i++){
        const r = new Record(origin.x + rnd(-100,100), origin.y + rnd(-80,80));
        r.originSys = 0;
        r.repTo = 0;
        r.localFixTo = -1;
        r.localMergeTo = -1;
        game.records.push(r);
      }

      game.sessionLen = L.sessionLen || 120.0;
      game.sessionLeft = game.sessionLen;
      game.sessionState = "live";

      game.task=null;
      game.taskRects=[];
      game.taskUntil=0;

      game.nextImpactIn = 8.0 + Math.random()*6.5;
      game.nextEventIn  = 7.5 + Math.random()*7.0;

      game.systemPopup.active=false;
      game.systemPopup.data=null;

      el("lvlLbl").textContent = `Level ${L.id}: ${L.name}`;
      syncMdmUI(); syncSessionUI(); syncDemoUI();
      tutorialStartIfLevel1();

      toast(`Start: <b>${L.name}</b>`, "Go");
    }

    // =========================
    // Buttons
    // =========================
    el("btnPrev").addEventListener("click", ()=>initLevel(game.lvlIndex-1));
    el("btnNext").addEventListener("click", ()=>initLevel(game.lvlIndex+1));

    el("btnMdm").addEventListener("click", ()=>{
      const L = LEVELS[game.lvlIndex];
      if(L.forceMdm) return;
      game.mdm = !game.mdm;
      // MDM removes need for local patches
      if(game.mdm){
        for(const r of game.records){ r.localFixTo = -1; r.localMergeTo = -1; }
      }
      syncMdmUI();
      toast(game.mdm ? "MDM aktiviert ‚Äî weniger Entstehung + bessere Verteilungskontrolle." : "MDM deaktiviert ‚Äî mehr Entstehung & sp√§te Folgen.", "MDM");
    });

    el("btnSession").addEventListener("click", ()=>{
      game.sessionOn = !game.sessionOn;
      syncSessionUI();
      toast(game.sessionOn ? `Session-Modus: ${Math.round(LEVELS[game.lvlIndex].sessionLen || 120)}s Challenge` : "Freies Spiel (ohne Timer)", "Session");
      initLevel(game.lvlIndex);
    });

    el("btnDemo").addEventListener("click", ()=>{
      game.demo.on = !game.demo.on;
      syncDemoUI();
      toast(game.demo.on ? "Auto-Demo aktiv (Messe-Modus)" : "Auto-Demo aus", "Demo");
    });

    el("btnShare").addEventListener("click", ()=>shareCanvasPNG());
    el("btnHeal").addEventListener("click", ()=>healAllWithMdm());

    el("btnReset").addEventListener("click", ()=>{
      if(baseline.taken){
        const L = LEVELS[game.lvlIndex];
        if(!L.forceMdm) game.mdm = !game.mdm;
        syncMdmUI();
      }
      initLevel(game.lvlIndex);
    });

    // =========================
    // Main loop
    // =========================
    let last = now();
    function frame(){
      const t = now();
      const dt = clamp((t-last)/1000, 0, 0.033);
      last = t;

      // toast auto-hide
      const toastEl = el("toast");
      if(toastEl.classList.contains("show") && (t - game.toastAt) > 3200) toastEl.classList.remove("show");

      // popup auto-hide
      if(game.systemPopup.active && t > game.systemPopup.until){
        game.systemPopup.active=false;
        game.systemPopup.data=null;
      }

      tutorialTick();

      if(!(game.sessionOn && game.sessionState==="ended")){
        spreadTick(dt);
        step(dt);
      }

      runDemo(dt);
      draw();
      updateHUD();

      requestAnimationFrame(frame);
    }

    // Boot
    resize();
    initLevel(0);
    requestAnimationFrame(frame);
  </script>
</body>
</html>
