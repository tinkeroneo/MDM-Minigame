<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Love your Data ðŸ’™ â€“ Mini Game</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#111827cc;
      --panel2:#0f172acc;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;

      /* NTT DATA "Future Blue" */
      --mdm-blue:#6485c1;

      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{height:100%; margin:0; background: radial-gradient(1200px 800px at 50% 0%, #111a2e 0%, var(--bg) 55%); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";}
    .wrap{height:100%; display:flex; flex-direction:column; padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom) 12px; gap:10px; max-width:980px; margin:0 auto;}
    header{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; background: linear-gradient(180deg, rgba(17,24,39,.72), rgba(17,24,39,.45)); border:1px solid rgba(255,255,255,.08); border-radius: var(--radius); box-shadow: var(--shadow);}
    .brand{display:flex; flex-direction:column; gap:2px; min-width:0;}
    .brand .t{font-weight:700; letter-spacing:.2px; display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .pill{display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); font-size:12px; color: var(--muted); white-space:nowrap;}
    .pill .dot{width:8px; height:8px; border-radius:99px; background: var(--warn); box-shadow:0 0 0 3px rgba(245,158,11,.15);}
    .pill.mdm{color:#e7eefc; border-color: rgba(100,133,193,.45); background: rgba(100,133,193,.16);}
    .pill.mdm .dot{background: var(--mdm-blue); box-shadow:0 0 0 3px rgba(100,133,193,.22);}
    .actions{display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    button{appearance:none; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06); color: var(--text); padding:10px 12px; border-radius: 14px; font-weight:650; font-size:14px; line-height:1; cursor:pointer; box-shadow: 0 8px 18px rgba(0,0,0,.25); transition: transform .06s ease, background .2s ease, border-color .2s ease; user-select:none;}
    button:active{transform: translateY(1px) scale(.99);}
    button.primary{border-color: rgba(100,133,193,.6); background: rgba(100,133,193,.18);}
    button.danger{border-color: rgba(239,68,68,.55); background: rgba(239,68,68,.14);}
    button.ghost{border-color: rgba(255,255,255,.10); background: rgba(255,255,255,.04);}

    .hud{display:grid; grid-template-columns: repeat(6, minmax(0,1fr)); gap:8px; padding:10px 12px; background: linear-gradient(180deg, rgba(15,23,42,.72), rgba(15,23,42,.35)); border:1px solid rgba(255,255,255,.08); border-radius: var(--radius); box-shadow: var(--shadow);}
    .stat{display:flex; flex-direction:column; gap:4px; min-width:0;}
    .stat .k{font-size:12px; color: var(--muted);}
    .stat .v{font-size:16px; font-weight:750; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .bar{height:8px; border-radius:999px; background: rgba(255,255,255,.08); overflow:hidden; border:1px solid rgba(255,255,255,.08);}
    .bar > i{display:block; height:100%; width:50%; background: var(--good); transition: width .2s ease;}

    .stage{position:relative; overflow:hidden; border-radius: var(--radius); border:1px solid rgba(255,255,255,.08); background: radial-gradient(900px 700px at 50% 30%, rgba(100,133,193,.16) 0%, rgba(0,0,0,0) 60%), linear-gradient(180deg, rgba(17,24,39,.55), rgba(3,7,18,.72)); box-shadow: var(--shadow); min-height: 360px; flex:1;}
    canvas{width:100%; height:100%; display:block;}

    .toast{position:absolute; top:10px; left:10px; padding:10px 12px; border-radius:14px; background: rgba(17,24,39,.74); border:1px solid rgba(255,255,255,.10); box-shadow: var(--shadow); max-width: min(560px, calc(100% - 20px)); transform: translateY(-6px); opacity:0; pointer-events:none; transition: opacity .25s ease, transform .25s ease; backdrop-filter: blur(10px); font-size:14px; line-height:1.25;}
    .toast.show{opacity:1; transform: translateY(0px);}
    .toast b{font-weight:800;}
    .toast .tag{display:inline-flex; align-items:center; gap:6px; margin-left:8px; padding:3px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06); font-size:12px; color: var(--muted);}

    .legend{
      position:absolute; right:10px; bottom:10px;
      padding:10px 12px;
      background: rgba(17,24,39,.62);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      backdrop-filter: blur(10px);
      font-size:12.5px;
      color: #d1d5db;
      display:flex;
      flex-direction:column;
      gap:8px;
      max-width: min(340px, calc(100% - 20px));
    }
    .legend .row{display:flex; align-items:center; gap:10px;}
    .sw{width:12px; height:12px; border-radius:99px; box-shadow: 0 0 0 3px rgba(255,255,255,.06);}
    .sw.g{background: var(--good); box-shadow:0 0 0 3px rgba(34,197,94,.15);}
    .sw.o{background: var(--warn); box-shadow:0 0 0 3px rgba(245,158,11,.18);}
    .sw.r{background: var(--bad); box-shadow:0 0 0 3px rgba(239,68,68,.18);}
    .sw.b{background: var(--mdm-blue); box-shadow:0 0 0 3px rgba(100,133,193,.20);}
    .legend b{font-weight:800;}
    .legend small{color: var(--muted); line-height:1.25;}

    @media (min-width: 820px){
      header{padding:12px 14px;}
      .stage{min-height: 520px;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="t">
          Love your Data
          <span class="pill"><span class="dot"></span><span id="lvlLbl">Level 1</span></span>
          <span id="mdmPill" class="pill mdm" style="display:none;"><span class="dot"></span>MDM aktiv</span>
          <span class="pill" id="timerPill"><span class="dot" style="background:rgba(255,255,255,.25); box-shadow:0 0 0 3px rgba(255,255,255,.08)"></span><span id="timerLbl">120s</span></span>
        </div>
        <div style="color:var(--muted); font-size:12.5px; line-height:1.2;">
          Tippen = Fix (rot) â€¢ Long-Press = Merge (orange Dubletten) â€¢ Ziel: Verbreitung stoppen, bevorâ€™s ðŸ’” wird.
        </div>
      </div>
      <div class="actions">
        <button id="btnPrev">â—€ï¸Ž</button>
        <button id="btnNext" class="primary">Next â–¶ï¸Ž</button>
        <button id="btnMdm" class="primary">MDM: Off</button>
        <button id="btnSession" class="ghost">Session: On</button>
        <button id="btnReset" class="danger">Reset</button>
      </div>
    </header>

    <div class="hud">
      <div class="stat">
        <div class="k">QualitÃ¤t</div>
        <div class="v"><span id="qVal">100</span>%</div>
        <div class="bar"><i id="qBar" style="width:100%"></i></div>
      </div>
      <div class="stat">
        <div class="k">Systeme</div>
        <div class="v" id="sysVal">1</div>
        <div class="k" style="margin-top:2px;">Verbreitung</div>
        <div class="v" id="spreadVal">niedrig</div>
      </div>
      <div class="stat">
        <div class="k">DatensÃ¤tze</div>
        <div class="v" id="recVal">10</div>
        <div class="k" style="margin-top:2px;">Fehler (rot)</div>
        <div class="v" id="errVal">0</div>
      </div>
      <div class="stat">
        <div class="k">Dubletten (orange)</div>
        <div class="v" id="dupVal">0</div>
        <div class="k" style="margin-top:2px;">Fixes</div>
        <div class="v" id="fixVal">0</div>
      </div>
      <div class="stat">
        <div class="k">Kosten</div>
        <div class="v" id="costVal">0 â‚¬</div>
        <div class="k" style="margin-top:2px;">Zeit</div>
        <div class="v" id="timeVal">0.0</div>
      </div>
      <div class="stat">
        <div class="k">Score (Session)</div>
        <div class="v" id="scoreVal">0</div>
        <div class="k" style="margin-top:2px;">Status</div>
        <div class="v" id="statusVal">live</div>
      </div>
    </div>

    <div class="stage" id="stage">
      <canvas id="c"></canvas>
      <div class="toast" id="toast"></div>

      <div class="legend">
        <div class="row"><span class="sw g"></span><div><b>GrÃ¼n</b>: sauber / valid</div></div>
        <div class="row"><span class="sw r"></span><div><b>Rot</b>: Fehler (z. B. fehlendes Feld, Tippfehler) â†’ propagiert</div></div>
        <div class="row"><span class="sw o"></span><div><b>Orange</b>: Dublette-Paar â†’ Long-Press zum Merge (Golden Record)</div></div>
        <div class="row"><span class="sw b"></span><div><b>Future Blue</b>: MDM aktiv (Validierung + Dublettenbremse)</div></div>
        <small>System-Kreise zeigen: wo Daten genutzt werden (ERP/CRM/Shop/BI/â€¦). SpÃ¤ter im Fluss = teurer.</small>
      </div>
    </div>
  </div>

  <script>
    // ===== Utilities =====
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const rnd = (a,b)=>a+Math.random()*(b-a);
    const now = ()=>performance.now();

    function fmtEuro(n){
      const v = Math.round(n);
      return v.toLocaleString("de-DE") + " â‚¬";
    }
    function getCSS(varName){
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }
    function qualityColor(q){
      if(q>=80) return getCSS("--good");
      if(q>=55) return getCSS("--warn");
      return getCSS("--bad");
    }

    // ===== Canvas =====
    const canvas = document.getElementById("c");
    const stage = document.getElementById("stage");
    const ctx = canvas.getContext("2d", { alpha: true });

    // ===== Content: system labels (simple, plausible) =====
    const SYSTEM_LABELS = [
      ["ERP"],
      ["ERP","CRM","Shop"],
      ["ERP","CRM","Shop","WMS","BI","MDM?"],
      ["ERP","CRM","Shop","WMS","BI","Support","Finance","PIM","DataLake"],
      ["ERP","CRM","Shop","WMS","BI","Support","Finance","PIM","DataLake"]
    ];

    // ===== Levels =====
    const LEVELS = [
      {
        id: 1, name: "First Date",
        systems: 1, records: 10,
        baseErrorRate: 0.012, duplicateRate: 0.000,
        spreadFactor: 0.25,
        costPerBadPerSec: 0.5, timeWeight: 1.0,
      },
      {
        id: 2, name: "Offene Beziehung",
        systems: 3, records: 18,
        baseErrorRate: 0.020, duplicateRate: 0.012,
        spreadFactor: 0.65,
        costPerBadPerSec: 1.8, timeWeight: 1.15,
      },
      {
        id: 3, name: "Commitment Issues",
        systems: 6, records: 28,
        baseErrorRate: 0.028, duplicateRate: 0.020,
        spreadFactor: 0.95,
        costPerBadPerSec: 3.2, timeWeight: 1.35,
      },
      {
        id: 4, name: "Toxisch",
        systems: 9, records: 40,
        baseErrorRate: 0.034, duplicateRate: 0.026,
        spreadFactor: 1.15,
        costPerBadPerSec: 4.6, timeWeight: 1.65,
      },
      {
        id: 5, name: "True Love (MDM)",
        systems: 9, records: 40,
        baseErrorRate: 0.016, duplicateRate: 0.006,
        spreadFactor: 0.35,
        costPerBadPerSec: 1.0, timeWeight: 0.95,
        forceMdm: true
      }
    ];

    // ===== Entities =====
    class Record {
      constructor(x,y){
        this.x=x; this.y=y;
        this.vx=rnd(-20,20);
        this.vy=rnd(-20,20);
        this.r=11;
        this.state="good"; // good | bad | dupA | dupB
        this.sys=0;
        this.id = Math.random().toString(16).slice(2);
        this.link = null;
        this.jitter = rnd(0,1000);
      }
    }

    const game = {
      viewport:{w:0,h:0},
      lvlIndex:0,
      mdm:false,
      systems:[],
      records:[],
      dpr:1,
      metrics:{quality:100, errors:0, dups:0, fixes:0, cost:0, timeSpent:0, score:0},
      input:{down:false, downAt:0, downPos:{x:0,y:0}},
      toastAt:0,

      // Session (Short Mode)
      sessionOn:true,
      sessionLen:120.0,
      sessionLeft:120.0,
      sessionState:"live", // live | ended
      endShown:false,

      // Propagation events
      lastEventAt:0,
      nextEventIn: 8.0,
      eventCooldown: 4.5,
    };

    function resize(){
      const r = stage.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2.25, window.devicePixelRatio || 1));
      canvas.width = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      canvas.style.width = r.width + "px";
      canvas.style.height = r.height + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
      game.viewport.w = r.width;
      game.viewport.h = r.height;
      game.dpr = dpr;
    }
    window.addEventListener("resize", resize);

    function buildSystems(n){
      const W = game.viewport.w, H = game.viewport.h;
      const pad = 74;
      const xs = [];
      if(n===1){ xs.push(W*0.5); }
      else for(let i=0;i<n;i++) xs.push(lerp(pad, W-pad, i/(n-1)));

      const yBase = H*0.33;
      const yAmp = Math.min(110, H*0.18);

      // Larger circles, smart scaling:
      const baseR = clamp(Math.min(46, Math.max(34, W*0.055)), 34, 46);

      const labels = (SYSTEM_LABELS[game.lvlIndex] || []).slice(0,n);
      const nodes = xs.map((x,i)=>{
        const phase = (i/(Math.max(1,n-1))) * Math.PI * 1.2;
        const y = yBase + Math.sin(phase) * yAmp;
        return {
          x, y,
          r: baseR,
          idx:i,
          label: labels[i] || ("SYS " + (i+1))
        };
      });
      return nodes;
    }

    function initLevel(idx){
      game.lvlIndex = clamp(idx, 0, LEVELS.length-1);
      const L = LEVELS[game.lvlIndex];

      if(L.forceMdm) game.mdm = true;

      game.metrics = {quality:100, errors:0, dups:0, fixes:0, cost:0, timeSpent:0, score:0};
      game.records = [];
      game.systems = buildSystems(L.systems);

      const s0 = game.systems[0] || {x:game.viewport.w/2, y:game.viewport.h/2};
      for(let i=0;i<L.records;i++){
        const r = new Record(s0.x + rnd(-90,90), s0.y + rnd(-70,70));
        r.sys = 0;
        game.records.push(r);
      }

      // Session reset
      game.sessionLeft = game.sessionLen;
      game.sessionState = "live";
      game.endShown = false;

      // Event timers reset
      game.lastEventAt = 0;
      game.nextEventIn = 6 + Math.random()*6;

      // UI labels
      document.getElementById("lvlLbl").textContent = `Level ${L.id}: ${L.name}`;
      document.getElementById("sysVal").textContent = String(L.systems);
      document.getElementById("recVal").textContent = String(L.records);
      syncMdmUI();
      syncSessionUI();
      toast(`Start: <b>${L.name}</b> <span class="tag">Rot=Fehler</span><span class="tag">Orange=Dublette</span>`);
    }

    function syncMdmUI(){
      const btn = document.getElementById("btnMdm");
      const pill = document.getElementById("mdmPill");
      const L = LEVELS[game.lvlIndex];
      const forced = !!L.forceMdm;

      if(game.mdm){
        btn.textContent = forced ? "MDM: On (locked)" : "MDM: On";
        pill.style.display = "inline-flex";
      } else {
        btn.textContent = "MDM: Off";
        pill.style.display = "none";
      }
      btn.disabled = forced;
      btn.style.opacity = forced ? 0.6 : 1;
    }

    function syncSessionUI(){
      document.getElementById("btnSession").textContent = `Session: ${game.sessionOn ? "On" : "Off"}`;
      document.getElementById("timerPill").style.display = game.sessionOn ? "inline-flex" : "none";
    }

    function computeQuality(){
      let bad=0, dup=0;
      for(const r of game.records){
        if(r.state==="bad") bad++;
        if(r.state==="dupA" || r.state==="dupB") dup++;
      }
      const total = game.records.length || 1;
      const q = clamp(100 - (bad/total)*65 - (dup/total)*55, 0, 100);
      game.metrics.errors = bad;
      game.metrics.dups = Math.floor(dup/2);
      game.metrics.quality = q;
    }

    // ===== Propagation Events (1) =====
    function maybeEvent(dt){
      if(game.sessionState !== "live") return;

      game.nextEventIn -= dt;
      if(game.nextEventIn > 0) return;

      // Cooldown
      const tNow = game.metrics.timeSpent;
      if((tNow - game.lastEventAt) < game.eventCooldown){
        game.nextEventIn = 1.0 + Math.random()*2.0;
        return;
      }

      const L = LEVELS[game.lvlIndex];
      const lateSystems = Math.max(1, Math.floor(L.systems * 0.45));
      const thresholdSys = Math.max(1, L.systems - lateSystems);

      // If bad data already reached later systems, trigger a visible "process incident"
      const badLate = game.records.filter(r => r.state==="bad" && r.sys >= thresholdSys).length;
      const dupLate = game.records.filter(r => (r.state==="dupA"||r.state==="dupB") && r.sys >= thresholdSys).length;

      if(badLate + dupLate === 0){
        // No incident yet -> schedule later
        game.nextEventIn = 4.0 + Math.random()*6.0;
        return;
      }

      // Incident severity scales with late bad/dup
      const sev = clamp((badLate*1.0 + dupLate*1.2) / 6.0, 0.3, 2.2);
      const baseSpike = 220 * sev * (1 + (L.systems/4));
      const spike = baseSpike * (game.mdm ? 0.35 : 1.0); // MDM dampens incidents strongly

      game.metrics.cost += spike;

      // Score penalty: late incidents hurt
      game.metrics.score -= Math.round(spike * 0.15);

      // Visual toast
      const what = (Math.random()<0.5) ? "Rechnungslauf" : "Versand/CRM";
      toast(`âš ï¸ Incident in <b>${what}</b>: falsche Daten im SpÃ¤t-System â†’ <b>${fmtEuro(spike)}</b> Extra-Kosten.`, "Propagation");

      game.lastEventAt = tNow;
      game.nextEventIn = 8.0 + Math.random()*8.0;
    }

    function spreadTick(dt){
      const L = LEVELS[game.lvlIndex];
      const mdm = game.mdm;

      // Stronger MDM effect (requested)
      const errRate = L.baseErrorRate * (mdm ? 0.30 : 1.0);
      const dupRate = L.duplicateRate * (mdm ? 0.22 : 1.0);
      const spread = L.spreadFactor * (mdm ? 0.28 : 1.0);

      // Advance records into later systems (integration/usage)
      for(const r of game.records){
        const advanceProb = (0.12 + (r.state!=="good" ? 0.09 : 0.0)) * dt;
        if(r.sys < game.systems.length-1 && Math.random() < advanceProb) r.sys++;

        // Become bad
        if(r.state==="good" && Math.random() < errRate * dt){
          r.state = "bad";
        }

        // Duplicate pair
        if(r.state==="good" && L.systems>=2 && Math.random() < dupRate * dt){
          const a = r;
          const b = new Record(a.x + rnd(-22,22), a.y + rnd(-22,22));
          b.sys = a.sys;
          a.state = "dupA";
          b.state = "dupB";
          a.link = b.id;
          b.link = a.id;
          game.records.push(b);
        }
      }

      // Propagation / infection
      const infectors = game.records.filter(r => r.state!=="good");
      if(infectors.length){
        const attempts = Math.min(42, infectors.length);
        for(let i=0;i<attempts;i++){
          const src = infectors[(Math.random()*infectors.length)|0];
          const cand = game.records[(Math.random()*game.records.length)|0];
          if(!cand || cand.state!=="good") continue;

          const dx = cand.x - src.x;
          const dy = cand.y - src.y;
          const dist2 = dx*dx + dy*dy;

          const sysFactor = (cand.sys / Math.max(1, (game.systems.length-1))) * 0.9 + 0.1;
          const radius = 85 + sysFactor*110;
          const p = spread * sysFactor * dt * (dist2 < radius*radius ? 0.55 : 0.14);

          if(Math.random() < p){
            cand.state = "bad";
          }
        }
      }

      computeQuality();

      // Cost accumulation (more obvious)
      const bad = game.metrics.errors;
      const dups = game.metrics.dups;
      const chaos = (bad*1.05 + dups*1.8);
      game.metrics.cost += chaos * L.costPerBadPerSec * dt;

      // Score: reward quality and fixes, punish cost + chaos
      game.metrics.score += Math.round((game.metrics.quality - 70) * 0.02);
      game.metrics.score += (mdm ? 1 : 0);

      game.metrics.timeSpent += dt * L.timeWeight;

      // Events
      maybeEvent(dt);

      // Session countdown
      if(game.sessionOn && game.sessionState==="live"){
        game.sessionLeft = Math.max(0, game.sessionLeft - dt);
        if(game.sessionLeft <= 0){
          game.sessionState = "ended";
        }
      }
    }

    // ===== Movement / drawing =====
    function step(dt){
      for(const r of game.records){
        const node = game.systems[r.sys] || {x:game.viewport.w/2, y:game.viewport.h/2};
        r.vx += rnd(-8,8) * dt;
        r.vy += rnd(-8,8) * dt;

        const t = (now() + r.jitter) * 0.001;
        const ox = Math.cos(t*1.5) * 18;
        const oy = Math.sin(t*1.2) * 14;

        const ax = (node.x+ox - r.x) * 0.8;
        const ay = (node.y+oy - r.y) * 0.8;
        r.vx += ax * dt;
        r.vy += ay * dt;

        r.vx *= (1 - 0.75*dt);
        r.vy *= (1 - 0.75*dt);

        r.x += r.vx * dt;
        r.y += r.vy * dt;

        const pad = 18;
        if(r.x < pad){ r.x = pad; r.vx *= -0.6; }
        if(r.y < pad){ r.y = pad; r.vy *= -0.6; }
        if(r.x > game.viewport.w - pad){ r.x = game.viewport.w - pad; r.vx *= -0.6; }
        if(r.y > game.viewport.h - pad){ r.y = game.viewport.h - pad; r.vy *= -0.6; }
      }
    }

    function drawHeart(x,y,s,stroke){
      ctx.save();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.bezierCurveTo(x - s, y - s, x - 2*s, y + s/2, x, y + 2*s);
      ctx.bezierCurveTo(x + 2*s, y + s/2, x + s, y - s, x, y);
      ctx.stroke();
      ctx.restore();
    }
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function draw(){
      const W = game.viewport.w, H = game.viewport.h;
      ctx.clearRect(0,0,W,H);

      // Subtle grid
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.strokeStyle = "white";
      ctx.lineWidth = 1;
      const stepG = 38;
      for(let x=0;x<W;x+=stepG){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for(let y=0;y<H;y+=stepG){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
      ctx.restore();

      // Connections
      ctx.save();
      ctx.lineWidth = 3;
      for(let i=0;i<game.systems.length;i++){
        const a = game.systems[i];
        if(i<game.systems.length-1){
          const b = game.systems[i+1];
          ctx.strokeStyle = "rgba(255,255,255,.14)";
          ctx.beginPath();
          ctx.moveTo(a.x,a.y);
          ctx.quadraticCurveTo((a.x+b.x)/2, (a.y+b.y)/2 - 40, b.x, b.y);
          ctx.stroke();
          drawHeart(lerp(a.x,b.x,0.5), lerp(a.y,b.y,0.5)-22, 7, "rgba(255,255,255,.14)");
        }
      }
      ctx.restore();

      // Systems (bigger + labeled)
      const mdmBlue = getCSS("--mdm-blue");
      for(const s of game.systems){
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,.06)";
        ctx.strokeStyle = "rgba(255,255,255,.18)";
        ctx.lineWidth = 2.2;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();

        if(game.mdm){
          ctx.globalAlpha = 0.18;
          ctx.strokeStyle = mdmBlue;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r+12, 0, Math.PI*2);
          ctx.stroke();
        }

        // Label
        ctx.globalAlpha = 0.92;
        ctx.fillStyle = "rgba(255,255,255,.86)";
        ctx.font = "800 13px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(s.label, s.x, s.y - 0.5);

        ctx.restore();
      }

      // Records
      for(const r of game.records){
        const col = (r.state==="good") ? "rgba(34,197,94,1)"
                  : (r.state==="bad") ? "rgba(239,68,68,1)"
                  : "rgba(245,158,11,1)";

        ctx.save();
        ctx.globalAlpha = (r.state==="good") ? 0.12 : 0.18;
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r+8, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(0,0,0,.45)";
        ctx.font = "800 12px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        let t = "âœ“";
        if(r.state==="bad") t = "!";
        if(r.state==="dupA" || r.state==="dupB") t = "â‰‹";
        ctx.fillText(t, r.x, r.y+0.5);
        ctx.restore();

        if((r.state==="dupA" || r.state==="dupB") && r.link){
          const other = game.records.find(x=>x.id===r.link);
          if(other){
            ctx.save();
            ctx.strokeStyle = "rgba(245,158,11,.22)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(r.x,r.y);
            ctx.lineTo(other.x, other.y);
            ctx.stroke();
            ctx.restore();
          }
        }
      }

      // Quality badge
      const q = game.metrics.quality;
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(17,24,39,.55)";
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 1;
      const bw = 168, bh = 44;
      ctx.beginPath();
      roundRect(ctx, W - bw - 10, 10, bw, bh, 14);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = qualityColor(q);
      ctx.font = "900 16px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(`QualitÃ¤t: ${Math.round(q)}%`, W - bw, 10 + bh/2);
      ctx.restore();

      // Session overlay when ended
      if(game.sessionOn && game.sessionState==="ended"){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.45)";
        ctx.fillRect(0,0,W,H);

        ctx.fillStyle = "rgba(17,24,39,.86)";
        ctx.strokeStyle = "rgba(255,255,255,.14)";
        ctx.lineWidth = 1;
        const pw = Math.min(520, W-30);
        const ph = 220;
        const px = (W-pw)/2, py = (H-ph)/2;
        ctx.beginPath();
        roundRect(ctx, px, py, pw, ph, 18);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "900 20px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Session Ende", W/2, py+42);

        ctx.font = "800 16px system-ui";
        ctx.fillStyle = getCSS("--mdm-blue");
        ctx.fillText(`Score: ${game.metrics.score}`, W/2, py+86);

        ctx.fillStyle = "rgba(255,255,255,.85)";
        ctx.font = "700 14px system-ui";
        ctx.fillText(`QualitÃ¤t: ${Math.round(game.metrics.quality)}% â€¢ Kosten: ${fmtEuro(game.metrics.cost)}`, W/2, py+120);

        ctx.fillStyle = "rgba(156,163,175,.95)";
        ctx.font = "700 13px system-ui";
        ctx.fillText("Tippe Reset fÃ¼r neue Runde.", W/2, py+162);
        ctx.restore();
      }
    }

    // ===== Input =====
    function getPos(evt){
      const r = canvas.getBoundingClientRect();
      if(evt.touches && evt.touches[0]) return {x: evt.touches[0].clientX - r.left, y: evt.touches[0].clientY - r.top};
      if(evt.changedTouches && evt.changedTouches[0]) return {x: evt.changedTouches[0].clientX - r.left, y: evt.changedTouches[0].clientY - r.top};
      return {x: evt.clientX - r.left, y: evt.clientY - r.top};
    }
    function findRecordAt(p){
      let best=null, bestD=1e9;
      for(const r of game.records){
        const dx=r.x-p.x, dy=r.y-p.y;
        const d = Math.sqrt(dx*dx+dy*dy);
        if(d < r.r + 10 && d < bestD){ bestD = d; best = r; }
      }
      return best;
    }
    function toast(html, tag){
      const el = document.getElementById("toast");
      el.innerHTML = html + (tag ? `<span class="tag">${tag}</span>` : "");
      el.classList.add("show");
      game.toastAt = now();
    }

    function fixRecord(r){
      if(game.sessionOn && game.sessionState!=="live") return;
      if(!r) return;

      if(r.state==="bad"){
        r.state="good";
        r.link=null;
        game.metrics.fixes++;
        game.metrics.score += 35;
        toast("Fix âœ”ï¸Ž â€” Rot (Fehler) korrigiert, bevor es weiter propagiert.", "Fix");
      } else if(r.state==="dupA" || r.state==="dupB"){
        toast("Orange = Dublette. Long-Press = Merge (Golden Record).", "Dubletten");
      } else {
        toast("GrÃ¼n = sauber ðŸ™‚", "OK");
      }
    }

    function mergeDupPair(r){
      if(game.sessionOn && game.sessionState!=="live") return false;
      if(!r) return false;
      if(!(r.state==="dupA" || r.state==="dupB") || !r.link) return false;
      const otherIndex = game.records.findIndex(x=>x.id===r.link);
      if(otherIndex < 0) return false;

      const other = game.records[otherIndex];
      r.state = "good";
      r.link = null;
      game.records.splice(otherIndex,1);

      game.metrics.fixes += 2;
      game.metrics.score += 60;
      toast("Merge ðŸ’™ â€” Dublette bereinigt (Golden Record).", "Merge");
      return true;
    }

    let longPressTimer = null;
    function onDown(evt){
      evt.preventDefault?.();
      if(game.sessionOn && game.sessionState!=="live") return;

      const p = getPos(evt);
      game.input.down = true;
      game.input.downAt = now();
      game.input.downPos = p;

      clearTimeout(longPressTimer);
      longPressTimer = setTimeout(()=>{
        if(!game.input.down) return;
        const r = findRecordAt(p);
        if(r && (r.state==="dupA" || r.state==="dupB")){
          mergeDupPair(r);
        } else {
          toast("Long-Press ist fÃ¼rs Dubletten-Merge (orange).", "Info");
        }
      }, 420);
    }
    function onUp(evt){
      evt.preventDefault?.();
      if(game.sessionOn && game.sessionState!=="live") return;

      const p = getPos(evt);
      const held = now() - game.input.downAt;
      game.input.down = false;
      clearTimeout(longPressTimer);
      if(held < 380){
        const r = findRecordAt(p);
        fixRecord(r);
      }
    }

    canvas.addEventListener("touchstart", onDown, {passive:false});
    canvas.addEventListener("touchend", onUp, {passive:false});
    canvas.addEventListener("mousedown", onDown);
    window.addEventListener("mouseup", onUp);

    // ===== Buttons =====
    document.getElementById("btnReset").addEventListener("click", ()=>initLevel(game.lvlIndex));
    document.getElementById("btnPrev").addEventListener("click", ()=>initLevel(game.lvlIndex - 1));
    document.getElementById("btnNext").addEventListener("click", ()=>initLevel(game.lvlIndex + 1));

    document.getElementById("btnMdm").addEventListener("click", ()=>{
      const L = LEVELS[game.lvlIndex];
      if(L.forceMdm) return;
      game.mdm = !game.mdm;
      syncMdmUI();
      toast(game.mdm
        ? "MDM aktiviert ðŸ’™ â€” Validierung + Dublettenbremse + weniger Incidents."
        : "MDM deaktiviert â€” jetzt wirdâ€™s schnell teuer ðŸ˜…"
      , "MDM");
    });

    document.getElementById("btnSession").addEventListener("click", ()=>{
      game.sessionOn = !game.sessionOn;
      syncSessionUI();
      toast(game.sessionOn ? "Session-Modus: 120s Challenge" : "Session-Modus aus (freies Spiel)", "Session");
      initLevel(game.lvlIndex);
    });

    // ===== HUD update =====
    function spreadLabel(){
      const L = LEVELS[game.lvlIndex];
      const s = L.spreadFactor * (game.mdm ? 0.28 : 1.0);
      if(s < 0.35) return "niedrig";
      if(s < 0.85) return "mittel";
      return "hoch";
    }

    function updateHUD(){
      computeQuality();
      const m = game.metrics;
      const q = m.quality;

      document.getElementById("qVal").textContent = String(Math.round(q));
      const bar = document.getElementById("qBar");
      bar.style.width = `${q}%`;
      bar.style.background = qualityColor(q);

      document.getElementById("errVal").textContent = String(m.errors);
      document.getElementById("dupVal").textContent = String(m.dups);
      document.getElementById("fixVal").textContent = String(m.fixes);
      document.getElementById("costVal").textContent = fmtEuro(m.cost);
      document.getElementById("timeVal").textContent = m.timeSpent.toFixed(1);
      document.getElementById("spreadVal").textContent = spreadLabel();

      document.getElementById("scoreVal").textContent = String(m.score);
      document.getElementById("statusVal").textContent = (game.sessionOn ? game.sessionState : "free");

      if(game.sessionOn){
        document.getElementById("timerLbl").textContent = `${Math.ceil(game.sessionLeft)}s`;
      }
    }

    // ===== Loop =====
    let last = now();
    function frame(){
      const t = now();
      const dt = clamp((t-last)/1000, 0, 0.033);
      last = t;

      if(!(game.sessionOn && game.sessionState==="ended")){
        spreadTick(dt);
        step(dt);
      } else {
        // One-time end toast
        if(!game.endShown){
          toast(`Session Ende. Score: <b>${game.metrics.score}</b> â€¢ QualitÃ¤t: <b>${Math.round(game.metrics.quality)}%</b>`, "Done");
          game.endShown = true;
        }
      }

      draw();
      updateHUD();

      const el = document.getElementById("toast");
      if(el.classList.contains("show") && (t - game.toastAt) > 2200){
        el.classList.remove("show");
      }

      requestAnimationFrame(frame);
    }

    // ===== Boot =====
    resize();
    initLevel(0);
    syncSessionUI();
    requestAnimationFrame(frame);
  </script>
</body>
</html>