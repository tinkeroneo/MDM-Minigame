<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Love your Data üíô ‚Äì Complete</title>
  <style>
    :root{
      --bg:#0b0f17;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --mdm-blue:#6485c1;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{
      height:100%; margin:0;
      background: radial-gradient(1200px 800px at 50% 0%, #111a2e 0%, var(--bg) 55%);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    .wrap{
      height:100%;
      display:flex; flex-direction:column;
      padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom) 12px;
      gap:10px;
      max-width: 980px; margin:0 auto;
    }
    header{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:10px; padding:10px 12px;
      background: linear-gradient(180deg, rgba(17,24,39,.72), rgba(17,24,39,.45));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .brand{display:flex; flex-direction:column; gap:4px; min-width:0;}
    .brand .t{
      font-weight:800; letter-spacing:.2px;
      display:flex; align-items:center; gap:8px; flex-wrap:wrap;
    }
    .sub{
      color:var(--muted);
      font-size:12.5px; line-height:1.25;
      max-width: 64ch;
    }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 10px; border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      font-size:12px; color: var(--muted);
      white-space:nowrap;
    }
    .pill .dot{
      width:8px; height:8px; border-radius:99px;
      background: var(--warn);
      box-shadow: 0 0 0 3px rgba(245,158,11,.15);
    }
    .pill.mdm{
      color:#e7eefc;
      border-color: rgba(100,133,193,.45);
      background: rgba(100,133,193,.16);
    }
    .pill.mdm .dot{
      background: var(--mdm-blue);
      box-shadow: 0 0 0 3px rgba(100,133,193,.22);
    }
    .actions{display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:700;
      font-size:14px; line-height:1;
      cursor:pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
      transition: transform .06s ease, background .2s ease, border-color .2s ease, opacity .2s ease;
      user-select:none;
    }
    button:active{transform: translateY(1px) scale(.99);}
    button.primary{border-color: rgba(100,133,193,.6); background: rgba(100,133,193,.18);}
    button.danger{border-color: rgba(239,68,68,.55); background: rgba(239,68,68,.14);}
    button.ghost{border-color: rgba(255,255,255,.10); background: rgba(255,255,255,.04);}
    .hud{
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:8px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(15,23,42,.72), rgba(15,23,42,.35));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .stat{display:flex; flex-direction:column; gap:4px; min-width:0;}
    .stat .k{font-size:12px; color: var(--muted);}
    .stat .v{font-size:16px; font-weight:850; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .bar{height:8px; border-radius:999px; background: rgba(255,255,255,.08); overflow:hidden; border:1px solid rgba(255,255,255,.08);}
    .bar > i{display:block; height:100%; width:50%; background: var(--good); transition: width .2s ease;}
    .stage{
      position:relative;
      overflow:hidden;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      background:
        radial-gradient(900px 700px at 50% 30%, rgba(100,133,193,.16) 0%, rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(17,24,39,.55), rgba(3,7,18,.72));
      box-shadow: var(--shadow);
      min-height: 360px;
      flex:1;
    }
    canvas{width:100%; height:100%; display:block;}
    .toast{
      position:absolute;
      top:10px; left:10px;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(17,24,39,.78);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      max-width: min(640px, calc(100% - 20px));
      transform: translateY(-6px);
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
      backdrop-filter: blur(10px);
      font-size:14px;
      line-height:1.25;
    }
    .toast.show{opacity:1; transform: translateY(0px);}
    .toast b{font-weight:900;}
    .toast .tag{
      display:inline-flex; align-items:center; gap:6px;
      margin-left:8px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }
    @media (min-width: 820px){
      header{padding:12px 14px;}
      .stage{min-height: 520px;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="t">
          Love your Data
          <span class="pill"><span class="dot"></span><span id="lvlLbl">Level 1</span></span>
          <span id="mdmPill" class="pill mdm" style="display:none;"><span class="dot"></span>MDM aktiv</span>
          <span id="timerPill" class="pill" style="display:none;">
            <span class="dot" style="background:rgba(255,255,255,.25); box-shadow:0 0 0 3px rgba(255,255,255,.08)"></span>
            <span id="timerLbl">120s</span>
          </span>
        </div>
        <div class="sub">
          Tippen = Fix (rot) ‚Ä¢ Long-Press auf orange = Merge ‚Ä¢ Long-Press auf System-Kreis = Kontext.  
          Stammdaten entstehen fr√ºh, replizieren sp√§ter ‚Äì die teuersten Folgen kommen am Ende.
        </div>
      </div>

      <div class="actions">
        <button id="btnPrev">‚óÄÔ∏é</button>
        <button id="btnNext" class="primary">Next ‚ñ∂Ô∏é</button>
        <button id="btnMdm" class="primary">MDM: Off</button>
        <button id="btnSession" class="ghost">Session: On</button>
        <button id="btnDemo" class="ghost">Demo: Off</button>
        <button id="btnShare" class="primary">Share</button>
        <button id="btnReset" class="danger">Reset</button>
      </div>
    </header>

    <div class="hud">
      <div class="stat">
        <div class="k">Qualit√§t</div>
        <div class="v"><span id="qVal">100</span>%</div>
        <div class="bar"><i id="qBar" style="width:100%"></i></div>
      </div>
      <div class="stat">
        <div class="k">Systeme</div>
        <div class="v" id="sysVal">1</div>
        <div class="k" style="margin-top:2px;">Replikation</div>
        <div class="v" id="spreadVal">niedrig</div>
      </div>
      <div class="stat">
        <div class="k">Datens√§tze</div>
        <div class="v" id="recVal">10</div>
        <div class="k" style="margin-top:2px;">Fehler (rot)</div>
        <div class="v" id="errVal">0</div>
      </div>
      <div class="stat">
        <div class="k">Dubletten (orange)</div>
        <div class="v" id="dupVal">0</div>
        <div class="k" style="margin-top:2px;">Fixes</div>
        <div class="v" id="fixVal">0</div>
      </div>
      <div class="stat">
        <div class="k">Kosten</div>
        <div class="v" id="costVal">0 ‚Ç¨</div>
        <div class="k" style="margin-top:2px;">Zeit</div>
        <div class="v" id="timeVal">0.0</div>
      </div>
      <div class="stat">
        <div class="k">Score (Session)</div>
        <div class="v" id="scoreVal">0</div>
        <div class="k" style="margin-top:2px;">Status</div>
        <div class="v" id="statusVal">live</div>
      </div>
    </div>

    <div class="stage" id="stage">
      <canvas id="c"></canvas>
      <div class="toast" id="toast"></div>
    </div>
  </div>

  <script>
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp  = (a,b,t)=>a+(b-a)*t;
    const rnd   = (a,b)=>a+Math.random()*(b-a);
    const now   = ()=>performance.now();
    const el = (id)=>document.getElementById(id);

    function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }
    function fmtEuro(n){ const v = Math.round(n); return v.toLocaleString("de-DE") + " ‚Ç¨"; }
    function qualityColor(q){ if(q>=80) return getCSS("--good"); if(q>=55) return getCSS("--warn"); return getCSS("--bad"); }
    function stars(n){ return "‚òÖ".repeat(n) + "‚òÜ".repeat(5-n); }

    const canvas = document.getElementById("c");
    const stage  = document.getElementById("stage");
    const ctx    = canvas.getContext("2d", { alpha: true });

    const SYSTEM_LABELS = [
      ["ERP"],
      ["ERP","CRM","Shop"],
      ["ERP","CRM","Shop","WMS","BI","Finance"],
      ["ERP","CRM","Shop","WMS","BI","Support","Finance","PIM","DataLake"],
      ["ERP","CRM","Shop","WMS","BI","Support","Finance","PIM","DataLake"]
    ];

    const SYSTEM_INFO = {
      "ERP":     { title:"ERP",      text:"Entstehung & Pflege von Stammdaten.", impact:"Fehler hier ‚Üí replizieren √ºberall hin." },
      "CRM":     { title:"CRM",      text:"Kundenpflege & Service-Kontext.",      impact:"Dubletten hier ‚Üí Kunde wird nicht erkannt." },
      "Shop":    { title:"Shop",     text:"Checkout nutzt replizierte Daten.",   impact:"Falsche Adresse ‚Üí Lieferung schief." },
      "WMS":     { title:"WMS",      text:"Versand nutzt replizierte Daten.",    impact:"Falscher Artikel ‚Üí Retouren & Kosten." },
      "BI":      { title:"BI",       text:"Reports aggregieren replizierte Daten.", impact:"Falsche KPIs ‚Üí falsche Entscheidungen." },
      "Finance": { title:"Finance",  text:"Abrechnung nutzt replizierte Daten.", impact:"Falsch ‚Üí Reklamationen & Vertrauensverlust." },
      "Support": { title:"Support",  text:"Tickets brauchen saubere IDs.",       impact:"Kunde nicht auffindbar ‚Üí Frust." },
      "PIM":     { title:"PIM",      text:"Produktstammdaten als Quelle.",       impact:"Inkonsistent ‚Üí falsche Infos im Shop." },
      "DataLake":{ title:"Data Lake",text:"Zentrale Datenbasis.",               impact:"Garbage in ‚Üí Garbage out." }
    };

    const TASKS = [
      { icon: "üìû", text: "Anruf vom Kundenservice" },
      { icon: "üìß", text: "Eilige Mail vom Vertrieb" },
      { icon: "üì¶", text: "Versandproblem kl√§ren" },
      { icon: "üí¨", text: "R√ºckfrage aus der Buchhaltung" }
    ];

    const IMPACTS = [
      { stars: 1, text: "Bestellung nie angekommen.", area: "Versand",       cost: [350, 900],  score: -120 },
      { stars: 2, text: "Rechnung falsch ‚Äì muss ich wieder hinterherlaufen?", area:"Finance",   cost: [220, 700],  score: -90 },
      { stars: 1, text: "Adresse war korrekt ‚Äì warum an Nachbarn geliefert?", area:"CRM/Ship", cost: [280, 1100], score: -140 },
      { stars: 2, text: "Doppelter Kundenstamm: Support findet mich nicht.",  area:"Support",  cost: [180, 650],  score: -80 },
      { stars: 1, text: "Retouren-Chaos wegen falscher Artikelstammdaten.",   area:"Shop/WMS", cost: [300, 1300], score: -150 },
      { stars: 3, text: "Lieferung versp√§tet, Status stimmt nicht.",          area:"Tracking", cost: [120, 420],  score: -45 }
    ];

    const LEVELS = [
      { id:1, name:"First Date (Tutorial)", systems:1, records:10, baseErrorRate:0.012, duplicateRate:0.000, replRate:0.55, costPerBadPerSec:0.5, timeWeight:1.0 },
      { id:2, name:"Offene Beziehung",     systems:3, records:18, baseErrorRate:0.020, duplicateRate:0.012, replRate:0.75, costPerBadPerSec:1.8, timeWeight:1.15 },
      { id:3, name:"Commitment Issues",    systems:6, records:28, baseErrorRate:0.028, duplicateRate:0.020, replRate:0.85, costPerBadPerSec:3.2, timeWeight:1.35 },
      { id:4, name:"Toxisch",              systems:9, records:40, baseErrorRate:0.034, duplicateRate:0.026, replRate:0.92, costPerBadPerSec:4.6, timeWeight:1.65 },
      { id:5, name:"True Love (MDM)",      systems:9, records:40, baseErrorRate:0.016, duplicateRate:0.006, replRate:0.62, costPerBadPerSec:1.0, timeWeight:0.95, forceMdm:true }
    ];

    class Record{
      constructor(x,y){
        this.x=x; this.y=y;
        this.vx=rnd(-18,18); this.vy=rnd(-18,18);
        this.r=11;
        this.state="good";
        this.originSys=0;
        this.repTo=0;
        this.id = Math.random().toString(16).slice(2);
        this.link=null;
        this.jitter=rnd(0,1000);
      }
    }

    const game = {
      viewport:{w:0,h:0},
      dpr:1,
      lvlIndex:0,
      mdm:false,
      systems:[],
      records:[],
      metrics:{quality:100, errors:0, dups:0, fixes:0, cost:0, timeSpent:0, score:0},

      sessionOn:true,
      sessionLen:120.0,
      sessionLeft:120.0,
      sessionState:"live",

      demo:{ on:false, nextActionIn:1.0, autoRestartIn:2.2 },

      tutorial:{ active:false, step:0 },
      tutorialImpactDone:false,

      activeTask:null,
      taskTimer:0,

      nextImpactIn:7.5,
      nextEventIn:7.0,

      systemPopup:{ active:false, x:0, y:0, data:null, until:0 },

      toastAt:0
    };

    let baseline = { taken:false, mdmState:false, quality:0, cost:0, score:0 };
    function snapshotBaseline(){
      baseline = {
        taken:true,
        mdmState: game.mdm,
        quality: Math.round(game.metrics.quality),
        cost: Math.round(game.metrics.cost),
        score: Math.round(game.metrics.score)
      };
    }

    function toast(html, tag){
      const t = el("toast");
      t.innerHTML = html + (tag ? `<span class="tag">${tag}</span>` : "");
      t.classList.add("show");
      game.toastAt = now();
    }

    function resize(){
      const r = stage.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2.25, window.devicePixelRatio || 1));
      canvas.width = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      canvas.style.width = r.width + "px";
      canvas.style.height = r.height + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
      game.viewport.w = r.width;
      game.viewport.h = r.height;
      game.dpr = dpr;
    }
    window.addEventListener("resize", resize);

    function buildSystems(n){
      const W = game.viewport.w, H = game.viewport.h;
      const pad = 74;
      const xs=[];
      if(n===1) xs.push(W*0.5);
      else for(let i=0;i<n;i++) xs.push(lerp(pad, W-pad, i/(n-1)));

      const yBase = H*0.33;
      const yAmp  = Math.min(110, H*0.18);
      const baseR = clamp(Math.min(46, Math.max(34, W*0.055)), 34, 46);

      const labels = (SYSTEM_LABELS[game.lvlIndex] || []).slice(0,n);
      return xs.map((x,i)=>{
        const phase = (i/(Math.max(1,n-1))) * Math.PI * 1.2;
        const y = yBase + Math.sin(phase) * yAmp;
        return { x, y, r: baseR, idx:i, label: labels[i] || ("SYS "+(i+1)) };
      });
    }

    function computeQuality(){
      let bad=0, dup=0;
      for(const r of game.records){
        if(r.state==="bad") bad++;
        if(r.state==="dupA" || r.state==="dupB") dup++;
      }
      const total = game.records.length || 1;
      const q = clamp(100 - (bad/total)*65 - (dup/total)*55, 0, 100);
      game.metrics.errors = bad;
      game.metrics.dups = Math.floor(dup/2);
      game.metrics.quality = q;
    }

    function replLabel(){
      const L = LEVELS[game.lvlIndex];
      const s = L.replRate * (game.mdm ? 0.45 : 1.0);
      if(s < 0.55) return "niedrig";
      if(s < 0.85) return "mittel";
      return "hoch";
    }

    function updateHUD(){
      computeQuality();
      const m = game.metrics;
      const q = m.quality;

      el("qVal").textContent = String(Math.round(q));
      const bar = el("qBar");
      bar.style.width = `${q}%`;
      bar.style.background = qualityColor(q);

      el("sysVal").textContent = String(LEVELS[game.lvlIndex].systems);
      el("recVal").textContent = String(LEVELS[game.lvlIndex].records);
      el("errVal").textContent = String(m.errors);
      el("dupVal").textContent = String(m.dups);
      el("fixVal").textContent = String(m.fixes);
      el("costVal").textContent = fmtEuro(m.cost);
      el("timeVal").textContent = m.timeSpent.toFixed(1);
      el("spreadVal").textContent = replLabel();

      el("scoreVal").textContent = String(Math.round(m.score));
      el("statusVal").textContent = game.sessionOn ? game.sessionState : "free";
      if(game.sessionOn) el("timerLbl").textContent = `${Math.ceil(game.sessionLeft)}s`;
    }

    function tutorialStartIfLevel1(){
      const L = LEVELS[game.lvlIndex];
      if(L.id !== 1){ game.tutorial.active=false; return; }
      game.tutorial.active=true;
      game.tutorial.step=0;
      game.tutorialImpactDone=false;
      toast("Ein ganz normaler Arbeitstag.", "Tutorial");
    }

    function tutorialTick(){
      if(!game.tutorial.active) return;
      switch(game.tutorial.step){
        case 0:
          game.records.forEach((r,i)=>{ r.state=(i===0?"bad":"good"); r.link=null; r.repTo=0; });
          toast("Du pflegst Stammdaten. Tippe rot zum Fix.", "Tutorial");
          game.tutorial.step=1;
          break;
        case 1:
          if(game.metrics.errors===0){
            toast("Gut ‚úîÔ∏è Jetzt l√§uft die Replikation an ‚Ä¶", "Tutorial");
            game.tutorial.step=2;
          }
          break;
        case 2:
          toast("W√§hrenddessen poppen Tasks auf ‚Äì nicht jeder kann immer alles pr√ºfen.", "Tutorial");
          game.tutorial.step=3;
          break;
        case 3:
          if(game.activeTask){
            if(!game.tutorialImpactDone){
              game.tutorialImpactDone=true;
              triggerImpact("Tutorial");
            }
            toast("Merksatz: Fehler entstehen fr√ºh. Folgen werden sp√§t teuer.", "Tutorial");
            game.tutorial.active=false;
          }
          break;
      }
    }

    function spawnTask(){
      if(game.activeTask || (game.sessionOn && game.sessionState==="ended")) return;
      game.activeTask = TASKS[(Math.random()*TASKS.length)|0];
      game.taskTimer = 3.5 + Math.random()*2.5;
      toast(`${game.activeTask.icon} ${game.activeTask.text}`, "Task");
    }

    function triggerImpact(reasonTag){
      const damp = game.mdm ? 0.35 : 1.0;
      const imp = IMPACTS[(Math.random()*IMPACTS.length)|0];
      const spike = (imp.cost[0] + Math.random()*(imp.cost[1]-imp.cost[0])) * damp;

      game.metrics.cost += spike;
      game.metrics.score += Math.round(imp.score * damp);

      if(!game.mdm && Math.random() < 0.45){
        const r = game.records.find(x=>x.state==="good");
        if(r) r.state="bad";
      }

      toast(`${stars(imp.stars)} <b>${imp.text}</b> <span class="tag">${imp.area}</span> <span class="tag">+${fmtEuro(spike)}</span>`, reasonTag || "Impact");
    }

    function lateExposureSignal(){
      const L = LEVELS[game.lvlIndex];
      const last = Math.max(0, L.systems-1);
      const lateThreshold = Math.max(2, Math.floor(last * 0.7));
      let bad=0, dup=0;
      for(const r of game.records){
        if(r.repTo >= lateThreshold){
          if(r.state==="bad") bad++;
          if(r.state==="dupA"||r.state==="dupB") dup++;
        }
      }
      return { badLate: bad, dupLate: dup, lateThreshold };
    }

    function maybePropagationEvent(dt){
      if(game.sessionOn && game.sessionState!=="live") return;
      game.nextEventIn -= dt;
      if(game.nextEventIn > 0) return;

      const L = LEVELS[game.lvlIndex];
      const { badLate, dupLate } = lateExposureSignal();
      if(badLate + dupLate === 0){
        game.nextEventIn = 4.0 + Math.random()*6.0;
        return;
      }

      const sev = clamp((badLate*1.0 + dupLate*1.2)/6.0, 0.3, 2.2);
      const baseSpike = 220 * sev * (1 + (L.systems/4));
      const spike = baseSpike * (game.mdm ? 0.35 : 1.0);

      game.metrics.cost += spike;
      game.metrics.score -= Math.round(spike * 0.15);

      const what = (Math.random()<0.5) ? "Rechnungslauf" : "Versand/CRM";
      toast(`‚ö†Ô∏è Incident in <b>${what}</b>: replizierte Fehler schlagen durch ‚Üí <b>${fmtEuro(spike)}</b> Extra-Kosten.`, "Propagation");

      game.nextEventIn = 8.0 + Math.random()*8.0;
    }

    function maybeImpact(dt){
      if(game.sessionOn && game.sessionState!=="live") return;
      game.nextImpactIn -= dt;
      if(game.nextImpactIn > 0) return;

      const { badLate, dupLate } = lateExposureSignal();
      const lateSignal = clamp((badLate*1.0 + dupLate*1.2) / 6.0, 0, 1);
      const taskBoost  = game.activeTask ? 0.25 : 0.0;

      if(lateSignal > 0.12 || game.activeTask){
        const p = clamp(0.18 + lateSignal*0.75 + taskBoost, 0, 0.95);
        if(Math.random() < p) triggerImpact(game.activeTask ? "Task‚ÜíImpact" : "Late‚ÜíImpact");
      }

      game.nextImpactIn = (game.mdm ? 10.5 : 7.5) + Math.random() * (game.mdm ? 9 : 7);
    }

    function spreadTick(dt){
      const L = LEVELS[game.lvlIndex];

      if(!game.activeTask && Math.random() < dt * 0.15) spawnTask();

      let taskFactor = 1.0;
      if(game.activeTask){
        game.taskTimer -= dt;
        taskFactor = 1.35;
        const penalty = game.mdm ? 0.004 : 0.012;
        if(Math.random() < penalty){
          const r = game.records.find(x=>x.state==="good");
          if(r) r.state="bad";
        }
        if(game.taskTimer <= 0) game.activeTask = null;
      }

      const errRate = L.baseErrorRate * (game.mdm ? 0.30 : 1.0) * taskFactor;
      const dupRate = L.duplicateRate * (game.mdm ? 0.22 : 1.0) * taskFactor;
      const replRate = L.replRate * (game.mdm ? 0.45 : 1.0) * (game.activeTask ? 1.10 : 1.0);

      for(const r of game.records){
        const early = (r.repTo <= 1);

        const advanceProb = replRate * 0.16 * dt;
        if(r.repTo < game.systems.length-1 && Math.random() < advanceProb) r.repTo++;

        if(r.state==="good"){
          const pErr = early ? errRate : errRate * 0.12;
          if(Math.random() < pErr * dt) r.state="bad";
        }

        if(r.state==="good" && early && L.systems>=2 && Math.random() < dupRate * dt){
          const a = r;
          const b = new Record(a.x + rnd(-22,22), a.y + rnd(-22,22));
          b.originSys = a.originSys;
          b.repTo = a.repTo;
          a.state="dupA"; b.state="dupB";
          a.link=b.id; b.link=a.id;
          game.records.push(b);
        }
      }

      const infectors = game.records.filter(r => r.state!=="good");
      if(infectors.length){
        const attempts = Math.min(40, infectors.length);
        for(let i=0;i<attempts;i++){
          const src = infectors[(Math.random()*infectors.length)|0];
          const cand = game.records[(Math.random()*game.records.length)|0];
          if(!cand || cand.state!=="good") continue;
          if(cand.repTo > 1) continue;

          const dx = cand.x - src.x, dy = cand.y - src.y;
          const dist2 = dx*dx + dy*dy;
          const radius = 120;
          const p = 0.06 * dt * (dist2 < radius*radius ? 0.9 : 0.2) * (game.mdm ? 0.45 : 1.0);
          if(Math.random() < p) cand.state="bad";
        }
      }

      computeQuality();

      let lateWeightSum = 0;
      for(const r of game.records){
        if(r.state==="good") continue;
        const frac = (r.repTo / Math.max(1, (game.systems.length-1)));
        lateWeightSum += 0.6 + frac*1.6;
      }
      game.metrics.cost += lateWeightSum * L.costPerBadPerSec * dt;

      game.metrics.score += Math.round((game.metrics.quality - 70) * 0.02);
      game.metrics.score += (game.mdm ? 1 : 0);
      game.metrics.timeSpent += dt * L.timeWeight;

      maybePropagationEvent(dt);
      maybeImpact(dt);

      if(game.sessionOn && game.sessionState==="live"){
        game.sessionLeft = Math.max(0, game.sessionLeft - dt);
        if(game.sessionLeft <= 0){
          game.sessionState="ended";
          if(!baseline.taken) snapshotBaseline();
        }
      }
    }

    function step(dt){
      const origin = game.systems[0] || {x:game.viewport.w/2, y:game.viewport.h/2};
      const topBand = 46;

      for(const r of game.records){
        const t = (now() + r.jitter) * 0.001;
        const ox = Math.cos(t*1.5) * 48;
        const oy = Math.sin(t*1.2) * 38;

        r.vx += rnd(-10,10) * dt;
        r.vy += rnd(-10,10) * dt;

        const ax = (origin.x+ox - r.x) * 1.0;
        const ay = (origin.y+oy - r.y) * 1.0;
        r.vx += ax * dt;
        r.vy += ay * dt;

        if(r.state==="bad") r.vy -= 42 * dt;

        r.vx *= (1 - 0.78*dt);
        r.vy *= (1 - 0.78*dt);

        r.x += r.vx * dt;
        r.y += r.vy * dt;

        const pad = 18;
        if(r.x < pad){ r.x=pad; r.vx*=-0.6; }
        if(r.y < pad){ r.y=pad; r.vy*=-0.6; }
        if(r.x > game.viewport.w-pad){ r.x=game.viewport.w-pad; r.vx*=-0.6; }
        if(r.y > game.viewport.h-pad){ r.y=game.viewport.h-pad; r.vy*=-0.6; }

        if(r.state==="bad" && r.y < topBand) r.y = topBand;
      }
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }
    function drawHeart(x,y,s,stroke){
      ctx.save();
      ctx.strokeStyle = stroke; ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.bezierCurveTo(x - s, y - s, x - 2*s, y + s/2, x, y + 2*s);
      ctx.bezierCurveTo(x + 2*s, y + s/2, x + s, y - s, x, y);
      ctx.stroke();
      ctx.restore();
    }
    function wrapText(text, x, y, maxWidth, lineHeight){
      const words = String(text).split(" ");
      let line="", yy=y;
      ctx.textAlign="left"; ctx.textBaseline="middle";
      for(let n=0;n<words.length;n++){
        const testLine = line + words[n] + " ";
        if(ctx.measureText(testLine).width > maxWidth && n>0){
          ctx.fillText(line, x, yy);
          line = words[n] + " ";
          yy += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, yy);
    }

    function drawEndCard(){
      const W=game.viewport.w, H=game.viewport.h;
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,.45)";
      ctx.fillRect(0,0,W,H);

      const pw = Math.min(560, W-26), ph=260;
      const px=(W-pw)/2, py=(H-ph)/2;

      ctx.fillStyle="rgba(17,24,39,.92)";
      ctx.strokeStyle="rgba(255,255,255,.14)";
      ctx.lineWidth=1;
      ctx.beginPath(); roundRect(ctx, px, py, pw, ph, 20); ctx.fill(); ctx.stroke();

      ctx.fillStyle="rgba(255,255,255,.92)";
      ctx.font="950 20px system-ui";
      ctx.textAlign="left"; ctx.textBaseline="middle";
      ctx.fillText("Love your Data üíô ‚Äì Session Ergebnis", px+18, py+34);

      ctx.fillStyle="rgba(156,163,175,.95)";
      ctx.font="700 13px system-ui";
      ctx.fillText(el("lvlLbl").textContent, px+18, py+60);

      ctx.fillStyle=getCSS("--mdm-blue");
      ctx.font="950 34px system-ui";
      ctx.fillText(`Score ${Math.round(game.metrics.score)}`, px+18, py+102);

      const q = Math.round(game.metrics.quality);
      ctx.fillStyle="rgba(255,255,255,.86)";
      ctx.font="850 14px system-ui";
      ctx.fillText(`Qualit√§t: ${q}%`, px+18, py+132);
      ctx.fillText(`Kosten: ${fmtEuro(game.metrics.cost)}`, px+180, py+132);

      ctx.strokeStyle="rgba(255,255,255,.10)";
      ctx.beginPath(); ctx.moveTo(px+18, py+150); ctx.lineTo(px+pw-18, py+150); ctx.stroke();

      if(baseline.taken){
        const cur = { quality: Math.round(game.metrics.quality), cost: Math.round(game.metrics.cost), score: Math.round(game.metrics.score) };
        const aLabel = baseline.mdmState ? "Mit MDM (Baseline)" : "Ohne MDM (Baseline)";
        const bLabel = game.mdm ? "Mit MDM (Jetzt)" : "Ohne MDM (Jetzt)";

        ctx.font="700 12.5px system-ui";
        ctx.fillStyle="rgba(156,163,175,.95)";
        ctx.fillText(`${aLabel}: Q ${baseline.quality}% ‚Ä¢ ${fmtEuro(baseline.cost)} ‚Ä¢ S ${baseline.score}`, px+18, py+176);

        ctx.fillStyle=getCSS("--mdm-blue");
        ctx.fillText(`${bLabel}: Q ${cur.quality}% ‚Ä¢ ${fmtEuro(cur.cost)} ‚Ä¢ S ${cur.score}`, px+18, py+198);

        const dq = cur.quality - baseline.quality;
        const dc = baseline.cost - cur.cost;
        const ds = cur.score - baseline.score;

        ctx.fillStyle="rgba(255,255,255,.86)";
        ctx.font="900 13px system-ui";
        ctx.fillText(`Œî Qualit√§t ${dq>=0?"+":""}${dq}%   Œî Kosten ${dc>=0?"-":"+"}${fmtEuro(Math.abs(dc))}   Œî Score ${ds>=0?"+":""}${ds}`, px+18, py+226);
      } else {
        ctx.fillStyle="rgba(156,163,175,.95)";
        ctx.font="700 12.5px system-ui";
        ctx.fillText("Tipp: zweite Runde starten f√ºr Vergleich (mit/ohne MDM).", px+18, py+188);
      }

      ctx.fillStyle="rgba(156,163,175,.9)";
      ctx.font="700 12px system-ui";
      ctx.fillText("Share: Button oben ‚Ä¢ Reset: neue Runde", px+18, py+248);
      ctx.restore();
    }

    async function shareCanvasPNG(){
      const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/png", 1.0));
      if(!blob){ toast("Export fehlgeschlagen.", "Share"); return; }
      const file = new File([blob], "love-your-data.png", { type:"image/png" });

      if(navigator.canShare && navigator.canShare({ files:[file] })){
        try{
          await navigator.share({ files:[file], title:"Love your Data ‚Äì Ergebnis", text:"Stammdatenqualit√§t spielerisch erkl√§rt." });
          toast("Geteilt ‚úîÔ∏è", "Share");
          return;
        }catch(e){}
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href=url; a.download="love-your-data.png";
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
      toast("PNG gespeichert ‚úîÔ∏è", "Share");
    }

    function draw(){
      const W=game.viewport.w, H=game.viewport.h;
      ctx.clearRect(0,0,W,H);

      ctx.save();
      ctx.globalAlpha=0.08;
      ctx.strokeStyle="white";
      ctx.lineWidth=1;
      const stepG=38;
      for(let x=0;x<W;x+=stepG){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for(let y=0;y<H;y+=stepG){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
      ctx.restore();

      ctx.save();
      ctx.lineWidth=3;
      for(let i=0;i<game.systems.length;i++){
        const a=game.systems[i];
        if(i<game.systems.length-1){
          const b=game.systems[i+1];
          ctx.strokeStyle="rgba(255,255,255,.14)";
          ctx.beginPath();
          ctx.moveTo(a.x,a.y);
          ctx.quadraticCurveTo((a.x+b.x)/2, (a.y+b.y)/2 - 40, b.x, b.y);
          ctx.stroke();
          drawHeart(lerp(a.x,b.x,0.5), lerp(a.y,b.y,0.5)-22, 7, "rgba(255,255,255,.14)");
        }
      }
      ctx.restore();

      const mdmBlue = getCSS("--mdm-blue");
      for(const s of game.systems){
        ctx.save();
        ctx.fillStyle="rgba(255,255,255,.06)";
        ctx.strokeStyle="rgba(255,255,255,.18)";
        ctx.lineWidth=2.2;
        ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); ctx.stroke();

        if(game.mdm){
          ctx.globalAlpha=0.18;
          ctx.strokeStyle=mdmBlue;
          ctx.lineWidth=3;
          ctx.beginPath(); ctx.arc(s.x,s.y,s.r+12,0,Math.PI*2); ctx.stroke();
          ctx.globalAlpha=1;
        }

        ctx.globalAlpha=0.92;
        ctx.fillStyle="rgba(255,255,255,.86)";
        ctx.font="900 13px system-ui";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(s.label, s.x, s.y-0.5);

        ctx.globalAlpha=0.7;
        ctx.font="800 10.5px system-ui";
        const tag = (s.idx<=1) ? "Quelle" : "Nutzung";
        ctx.fillText(tag, s.x, s.y+18);

        ctx.restore();
      }

      // replica ghosts
      ctx.save();
      for(const r of game.records){
        if(r.repTo <= 0) continue;
        const col = (r.state==="good") ? "rgba(34,197,94,.20)"
                  : (r.state==="bad")  ? "rgba(239,68,68,.26)"
                  :                      "rgba(245,158,11,.24)";
        ctx.fillStyle = col;
        for(let i=1;i<=r.repTo;i++){
          const s = game.systems[i];
          if(!s) continue;
          const t = (r.jitter + i*777) * 0.001;
          const ox = Math.cos(t*1.3) * 14;
          const oy = Math.sin(t*1.1) * 10;
          ctx.beginPath();
          ctx.arc(s.x+ox, s.y+oy, 4.2, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();

      const order = (st)=> (st==="bad"?2:(st==="dupA"||st==="dupB")?1:0);
      const recs = [...game.records].sort((a,b)=>order(a.state)-order(b.state));
      for(const r of recs){
        const col = (r.state==="good") ? "rgba(34,197,94,1)"
                  : (r.state==="bad")  ? "rgba(239,68,68,1)"
                  :                      "rgba(245,158,11,1)";

        ctx.save();
        ctx.globalAlpha = (r.state==="good") ? 0.12 : 0.20;
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(r.x,r.y,r.r+8,0,Math.PI*2); ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.fill();

        ctx.fillStyle="rgba(0,0,0,.45)";
        ctx.font="900 12px system-ui";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        let t="‚úì"; if(r.state==="bad") t="!"; if(r.state==="dupA"||r.state==="dupB") t="‚âã";
        ctx.fillText(t, r.x, r.y+0.5);
        ctx.restore();

        if((r.state==="dupA"||r.state==="dupB") && r.link){
          const other = game.records.find(x=>x.id===r.link);
          if(other){
            ctx.save();
            ctx.strokeStyle="rgba(245,158,11,.22)";
            ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(r.x,r.y); ctx.lineTo(other.x,other.y); ctx.stroke();
            ctx.restore();
          }
        }
      }

      const q=game.metrics.quality;
      ctx.save();
      ctx.globalAlpha=0.92;
      ctx.fillStyle="rgba(17,24,39,.55)";
      ctx.strokeStyle="rgba(255,255,255,.10)";
      ctx.lineWidth=1;
      const bw=168,bh=44;
      ctx.beginPath(); roundRect(ctx, W-bw-10, 10, bw, bh, 14); ctx.fill(); ctx.stroke();
      ctx.fillStyle=qualityColor(q);
      ctx.font="950 16px system-ui";
      ctx.textAlign="left"; ctx.textBaseline="middle";
      ctx.fillText(`Qualit√§t: ${Math.round(q)}%`, W-bw, 10+bh/2);
      ctx.restore();

      if(game.systemPopup.active && game.systemPopup.data){
        const {title,text,impact} = game.systemPopup.data;
        ctx.save();
        ctx.globalAlpha=0.95;
        ctx.fillStyle="rgba(17,24,39,.92)";
        ctx.strokeStyle="rgba(255,255,255,.14)";
        ctx.lineWidth=1;

        const w=Math.min(340, W-40), h=140;
        const x=clamp(game.systemPopup.x - w/2, 20, W-w-20);
        const y=clamp(game.systemPopup.y + 40, 20, H-h-20);

        ctx.beginPath(); roundRect(ctx,x,y,w,h,14); ctx.fill(); ctx.stroke();

        ctx.fillStyle="white";
        ctx.font="900 14px system-ui";
        ctx.textAlign="left"; ctx.textBaseline="middle";
        ctx.fillText(title, x+14, y+24);

        ctx.fillStyle="rgba(229,231,235,.9)";
        ctx.font="650 13px system-ui";
        ctx.fillText(text, x+14, y+50);

        ctx.fillStyle="rgba(239,68,68,.92)";
        ctx.font="800 12.5px system-ui";
        ctx.fillText("Folge:", x+14, y+78);

        ctx.fillStyle="rgba(229,231,235,.85)";
        ctx.font="700 12.5px system-ui";
        wrapText(impact, x+64, y+78, w-78, 15);

        if(game.mdm){
          ctx.fillStyle=mdmBlue;
          ctx.font="800 12.5px system-ui";
          ctx.fillText("MDM stoppt fr√ºh (Validierung + Golden Record).", x+14, y+118);
        }

        ctx.restore();
      }

      if(game.sessionOn && game.sessionState==="ended") drawEndCard();
    }

    function getPos(evt){
      const r = canvas.getBoundingClientRect();
      if(evt.touches && evt.touches[0]) return {x: evt.touches[0].clientX - r.left, y: evt.touches[0].clientY - r.top};
      if(evt.changedTouches && evt.changedTouches[0]) return {x: evt.changedTouches[0].clientX - r.left, y: evt.changedTouches[0].clientY - r.top};
      return {x: evt.clientX - r.left, y: evt.clientY - r.top};
    }

    function findRecordAt(p){
      let best=null, bestD=1e9;
      for(const r of game.records){
        const dx=r.x-p.x, dy=r.y-p.y;
        const d=Math.sqrt(dx*dx+dy*dy);
        const extra = (r.state==="bad") ? 10 : 0;
        if(d < r.r + 22 + extra && d < bestD){ bestD=d; best=r; }
      }
      return best;
    }

    function findSystemAt(p){
      for(const s of game.systems){
        const dx=p.x-s.x, dy=p.y-s.y;
        const d=Math.sqrt(dx*dx+dy*dy);
        if(d < s.r + 16) return s;
      }
      return null;
    }

    function fixRecord(r){
      if(!r) return;
      if(game.sessionOn && game.sessionState!=="live") return;

      if(r.state==="bad"){
        r.state="good"; r.link=null;
        game.metrics.fixes++;
        game.metrics.score += 35;
        toast("Fix ‚úîÔ∏é ‚Äî Fehler am Ursprung bereinigt (wirkt √ºberall).", "Fix");
      } else if(r.state==="dupA" || r.state==="dupB"){
        toast("Orange = Dublette. Long-Press = Merge (Golden Record).", "Dubletten");
      } else {
        toast("Gr√ºn = sauber.", "OK");
      }
    }

    function mergeDupPair(r){
      if(!r) return false;
      if(game.sessionOn && game.sessionState!=="live") return false;
      if(!(r.state==="dupA" || r.state==="dupB") || !r.link) return false;

      const otherIndex = game.records.findIndex(x=>x.id===r.link);
      if(otherIndex < 0) return false;
      const other = game.records[otherIndex];

      r.x = (r.x + other.x)/2;
      r.y = (r.y + other.y)/2;

      r.state="good";
      r.link=null;
      game.records.splice(otherIndex,1);

      game.metrics.fixes += 2;
      game.metrics.score += 60;
      toast("Merge üíô ‚Äî Dublette bereinigt (Golden Record).", "Merge");
      return true;
    }

    function openSystemPopup(sys){
      const info = SYSTEM_INFO[sys.label];
      if(!info) return;
      game.systemPopup.active=true;
      game.systemPopup.x=sys.x;
      game.systemPopup.y=sys.y;
      game.systemPopup.data=info;
      game.systemPopup.until=now()+4500;
      toast(`${info.title}: ${info.text}`, "System");
    }

    let longPressTimer=null;
    let downAt=0;
    let pressContext=null;
    let pressTarget=null;

    function onDown(evt){
      evt.preventDefault?.();
      if(game.sessionOn && game.sessionState!=="live") return;

      const p = getPos(evt);
      downAt = now();

      const rec = findRecordAt(p);
      if(rec){
        pressContext="record";
        pressTarget=rec;
      } else {
        const sys = findSystemAt(p);
        if(sys){
          pressContext="system";
          pressTarget=sys;
        } else {
          pressContext=null;
          pressTarget=null;
        }
      }

      clearTimeout(longPressTimer);
      longPressTimer = setTimeout(()=>{
        if(pressContext==="record"){
          if(pressTarget && (pressTarget.state==="dupA"||pressTarget.state==="dupB")) mergeDupPair(pressTarget);
        } else if(pressContext==="system"){
          if(pressTarget) openSystemPopup(pressTarget);
        }
      }, 420);
    }

    function onUp(evt){
      evt.preventDefault?.();

      if(game.systemPopup.active){
        game.systemPopup.active=false;
        game.systemPopup.data=null;
        return;
      }

      if(game.sessionOn && game.sessionState!=="live") return;

      clearTimeout(longPressTimer);
      const held = now() - downAt;

      if(held < 380 && pressContext==="record" && pressTarget) fixRecord(pressTarget);

      pressContext=null;
      pressTarget=null;
    }

    canvas.addEventListener("touchstart", onDown, {passive:false});
    canvas.addEventListener("touchend",   onUp,   {passive:false});
    canvas.addEventListener("mousedown",  onDown);
    window.addEventListener("mouseup",    onUp);

    function syncMdmUI(){
      const L = LEVELS[game.lvlIndex];
      const forced = !!L.forceMdm;
      const btn = el("btnMdm");
      const pill = el("mdmPill");

      if(game.mdm){
        btn.textContent = forced ? "MDM: On (locked)" : "MDM: On";
        pill.style.display="inline-flex";
      } else {
        btn.textContent = "MDM: Off";
        pill.style.display="none";
      }
      btn.disabled = forced;
      btn.style.opacity = forced ? 0.6 : 1;
    }
    function syncSessionUI(){
      el("btnSession").textContent = `Session: ${game.sessionOn ? "On" : "Off"}`;
      el("timerPill").style.display = game.sessionOn ? "inline-flex" : "none";
    }
    function syncDemoUI(){
      el("btnDemo").textContent = `Demo: ${game.demo.on ? "On" : "Off"}`;
    }

    function runDemo(dt){
      if(!game.demo.on) return;

      if(game.sessionOn && game.sessionState==="ended"){
        game.demo.autoRestartIn -= dt;
        if(game.demo.autoRestartIn <= 0){
          const L = LEVELS[game.lvlIndex];
          if(!L.forceMdm) game.mdm = !game.mdm;
          syncMdmUI();
          initLevel(game.lvlIndex);

          game.demo.autoRestartIn = 2.2 + Math.random()*1.5;
          game.demo.nextActionIn  = 0.9 + Math.random()*0.8;
        }
        return;
      }

      game.demo.nextActionIn -= dt;
      if(game.demo.nextActionIn > 0) return;
      game.demo.nextActionIn = 0.55 + Math.random()*0.9;

      const bad = game.records.find(r=>r.state==="bad");
      if(bad){ fixRecord(bad); return; }
      const dup = game.records.find(r=>(r.state==="dupA"||r.state==="dupB"));
      if(dup){ mergeDupPair(dup); return; }
    }

    function initLevel(idx){
      game.lvlIndex = clamp(idx, 0, LEVELS.length-1);
      const L = LEVELS[game.lvlIndex];
      if(L.forceMdm) game.mdm = true;

      game.metrics = {quality:100, errors:0, dups:0, fixes:0, cost:0, timeSpent:0, score:0};
      game.records = [];
      game.systems = buildSystems(L.systems);

      const origin = game.systems[0] || {x:game.viewport.w/2, y:game.viewport.h/2};
      for(let i=0;i<L.records;i++){
        const r = new Record(origin.x + rnd(-100,100), origin.y + rnd(-80,80));
        r.originSys = 0;
        r.repTo = 0;
        game.records.push(r);
      }

      game.sessionLeft = game.sessionLen;
      game.sessionState = "live";

      game.activeTask=null;
      game.taskTimer=0;
      game.nextImpactIn = 6.5 + Math.random()*5.5;
      game.nextEventIn  = 6.0 + Math.random()*6.0;

      game.systemPopup.active=false;
      game.systemPopup.data=null;

      el("lvlLbl").textContent = `Level ${L.id}: ${L.name}`;
      syncMdmUI(); syncSessionUI(); syncDemoUI();
      tutorialStartIfLevel1();
      toast(`Start: <b>${L.name}</b>`, "Go");
    }

    el("btnPrev").addEventListener("click", ()=>initLevel(game.lvlIndex-1));
    el("btnNext").addEventListener("click", ()=>initLevel(game.lvlIndex+1));

    el("btnMdm").addEventListener("click", ()=>{
      const L = LEVELS[game.lvlIndex];
      if(L.forceMdm) return;
      game.mdm = !game.mdm;
      syncMdmUI();
      toast(game.mdm ? "MDM aktiviert ‚Äî Validierung + Dublettenbremse + weniger sp√§te Folgen." : "MDM deaktiviert ‚Äî Fehler replizieren schneller.", "MDM");
    });

    el("btnSession").addEventListener("click", ()=>{
      game.sessionOn = !game.sessionOn;
      syncSessionUI();
      toast(game.sessionOn ? "Session-Modus: 120s Challenge" : "Freies Spiel (ohne Timer)", "Session");
      initLevel(game.lvlIndex);
    });

    el("btnDemo").addEventListener("click", ()=>{
      game.demo.on = !game.demo.on;
      syncDemoUI();
      toast(game.demo.on ? "Auto-Demo aktiv (Messe-Modus)" : "Auto-Demo aus", "Demo");
    });

    el("btnShare").addEventListener("click", ()=>shareCanvasPNG());

    el("btnReset").addEventListener("click", ()=>{
      if(baseline.taken){
        const L = LEVELS[game.lvlIndex];
        if(!L.forceMdm) game.mdm = !game.mdm;
        syncMdmUI();
      }
      initLevel(game.lvlIndex);
    });

    let last = now();
    function frame(){
      const t = now();
      const dt = clamp((t-last)/1000, 0, 0.033);
      last = t;

      const toastEl = el("toast");
      if(toastEl.classList.contains("show") && (t - game.toastAt) > 2400) toastEl.classList.remove("show");

      if(game.systemPopup.active && t > game.systemPopup.until){
        game.systemPopup.active=false;
        game.systemPopup.data=null;
      }

      tutorialTick();

      if(!(game.sessionOn && game.sessionState==="ended")){
        spreadTick(dt);
        step(dt);
      }

      runDemo(dt);
      draw();
      updateHUD();

      requestAnimationFrame(frame);
    }

    resize();
    initLevel(0);
    requestAnimationFrame(frame);
  </script>
</body>
</html>
