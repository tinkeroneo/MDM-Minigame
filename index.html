<!doctype html>
<html lang="de">
<head>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#6485c1">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Love your Data üíô ‚Äì Complete v14.7</title>
  <style>
    :root{
      --bg:#0b0f17;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --mdm-blue:#6485c1; /* Future Blue */
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{
      height:100%; margin:0;
      background: radial-gradient(1200px 800px at 50% 0%, #111a2e 0%, var(--bg) 55%);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    .wrap{
      height:100%;
      display:flex; flex-direction:column;
      padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom) 12px;
      gap:10px;
      max-width: 980px; margin:0 auto;
    }
    header{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:10px; padding:10px 12px;
      background: linear-gradient(180deg, rgba(17,24,39,.72), rgba(17,24,39,.45));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .brand{display:flex; flex-direction:column; gap:4px; min-width:0;}
    .brand .t{
      font-weight:800; letter-spacing:.2px;
      display:flex; align-items:center; gap:8px; flex-wrap:wrap;
    }
    .sub{
      color:var(--muted);
      font-size:12.5px; line-height:1.25;
      max-width: 70ch;
    }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 10px; border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      font-size:12px; color: var(--muted);
      white-space:nowrap;
    }
    .pill .dot{
      width:8px; height:8px; border-radius:99px;
      background: var(--warn);
      box-shadow: 0 0 0 3px rgba(245,158,11,.15);
    }
    .pill.mdm{
      color:#e7eefc;
      border-color: rgba(100,133,193,.45);
      background: rgba(100,133,193,.16);
    }
    .pill.mdm .dot{
      background: var(--mdm-blue);
      box-shadow: 0 0 0 3px rgba(100,133,193,.22);
    }
    .actions{display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:700;
      font-size:14px; line-height:1;
      cursor:pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
      transition: transform .06s ease, background .2s ease, border-color .2s ease, opacity .2s ease;
      user-select:none;
    }
    button:active{transform: translateY(1px) scale(.99);}
    button.primary{border-color: rgba(100,133,193,.6); background: rgba(100,133,193,.18);}
    button.danger{border-color: rgba(239,68,68,.55); background: rgba(239,68,68,.14);}
    button.ghost{border-color: rgba(255,255,255,.10); background: rgba(255,255,255,.04);}
    .hud{
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap:8px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(15,23,42,.72), rgba(15,23,42,.35));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .stat{display:flex; flex-direction:column; gap:4px; min-width:0;}
    .stat .k{font-size:12px; color: var(--muted);}
    .stat .v{font-size:16px; font-weight:850; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .bar{height:8px; border-radius:999px; background: rgba(255,255,255,.08); overflow:hidden; border:1px solid rgba(255,255,255,.08);}
    .bar > i{display:block; height:100%; width:50%; background: var(--good); transition: width .2s ease;}
    .stage{
      position:relative;
      overflow:hidden;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      background:
        radial-gradient(900px 700px at 50% 30%, rgba(100,133,193,.16) 0%, rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(17,24,39,.55), rgba(3,7,18,.72));
      box-shadow: var(--shadow);
      min-height: 360px;
      flex:1;
    }
    canvas{width:100%; height:100%; display:block;}
    .toast{
      position:absolute;
      top:10px; left:10px;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(17,24,39,.78);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      max-width: min(700px, calc(100% - 20px));
      transform: translateY(-6px);
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
      backdrop-filter: blur(10px);
      font-size:14px;
      line-height:1.25;
    }
    .toast.show{opacity:1; transform: translateY(0px);}
    .toast b{font-weight:900;}
    .toast .tag{
      display:inline-flex; align-items:center; gap:6px;
      margin-left:8px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }
    @media (min-width: 820px){
      header{padding:12px 14px;}
      .stage{min-height: 520px;}
    }
  
    /* Mini game overlay */
    .mini{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(6,10,18,.72); z-index:80; padding:16px; }
    .mini.hidden{ display:none; }
    .miniCard{ width:min(420px, 92vw); background:rgba(18,22,34,.95);
      border:1px solid rgba(255,255,255,.08); border-radius:18px;
      box-shadow:0 18px 70px rgba(0,0,0,.45); padding:14px 14px 16px; }
    .miniHead{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .miniTitle{ font-weight:800; letter-spacing:.2px; }
    .miniClose{ border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.06);
      color:#eaf0ff; border-radius:12px; padding:8px 10px; font-weight:700; }
    .miniSub{ margin:6px 0 10px; color:rgba(234,240,255,.70); font-size:13px; }
    #miniCanvas{ width:100%; height:auto; border-radius:14px; background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06); }
    .miniControls{ display:flex; gap:8px; margin-top:10px; }
    .miniBtn{ flex:1; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.07);
      color:#eaf0ff; border-radius:14px; padding:10px 10px; font-weight:800; }
    .miniBtn.wide{ flex:1.4; }
    .miniFooter{ display:flex; justify-content:space-between; align-items:center; margin-top:10px; color:rgba(234,240,255,.82); }

    .miniGrid{ display:grid; grid-template-columns: repeat(4, 1fr); gap:10px; margin-top:10px; }
    .miniTile{
      aspect-ratio: 1 / 1;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      letter-spacing:.3px;
      color:rgba(234,240,255,.90);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      position:relative;
      overflow:hidden;
    }
    .miniTile:active{ transform: scale(.98); }
    .miniTile .face{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:18px; }
    .miniTile .back{ background:rgba(100,133,193,.16); }
    .miniTile.flipped{ background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.16); }
    .miniTile.matched{ background:rgba(100,133,193,.18); border-color:rgba(100,133,193,.35); }



    /* Toast (mobile-safe, non-blocking) */
    .toastWrap{display:none !important;}

    .toastCard{position:relative;margin:8px auto 0 auto;pointer-events:auto;min-width:min(520px, calc(100vw - 24px));max-width:min(720px, calc(100vw - 24px));border-radius:18px;padding:12px 14px;background:rgba(10,16,28,.72);border:1px solid rgba(140,170,230,.18);backdrop-filter: blur(10px);-webkit-backdrop-filter: blur(10px);box-shadow: 0 14px 38px rgba(0,0,0,.28);opacity:0;transform:translateY(6px);transition:opacity .18s ease, transform .18s ease;}
    .toastHead{ font-weight:900; margin-bottom:4px; color: rgba(234,240,255,.92); }
    .toastBody{ color: rgba(234,240,255,.78); }
    .toastBody b{font-weight:900;}
    .toastBody .tag{
      display:inline-flex; align-items:center; gap:6px;
      margin-left:8px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }


    /* Mobile-first layout fix (11.1) */
    @media (max-width: 520px){
      .topRow{ flex-direction: column; align-items: stretch; gap:10px; }
      .topLeft{ width:100%; }
      .topRight{ width:100%; display:flex; flex-wrap:wrap; justify-content:flex-end; gap:10px; }
      .topRight .btn{ flex: 1 1 auto; min-width: 120px; }
      .panel{ padding: 14px; }
      .boardWrap{ padding: 12px; }
      canvas{ max-width:100%; height:auto; }
    }


    /* Collapsible top area (11.3) */
    .hudToggle{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      margin: 0 0 10px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      color: rgba(234,240,255,.92);
      font-weight:900;
      letter-spacing:.2px;
      -webkit-tap-highlight-color: transparent;
    }
    .hudToggleLeft{ display:flex; align-items:baseline; gap:10px; flex-wrap:wrap; }
    .hudTitle{ font-size:18px; }
    .hudLevelTiny{ font-size:14px; color: rgba(234,240,255,.68); font-weight:800; }
    body.hudCollapsed .hudChevron{ transform: rotate(-90deg); }
    .hudChevron{ opacity:.8; font-size:18px; transition: transform .18s ease; }
    .hudWrap{ position:relative; }
    body.hudCollapsed #hudWrap header{ display:none; }
    body.hudCollapsed #hudWrap{ margin-top: -2px; }
    body.hudCollapsed #hudWrap .hud{ display:flex; }


    @media (min-width: 760px){
      .hudToggle{ max-width: 720px; }
    }


    /* 11.4: ensure collapse works + remove duplicate title */
    #hudWrap header h1{ display:none; }
    #hudWrap header .brand{ display:none; }


    /* Task Bottom Sheet (12.5) */
    .taskSheet{
      position:fixed;
      left:12px;
      right:12px;
      bottom:max(12px, env(safe-area-inset-bottom));
      z-index:60;
      padding:12px 12px 14px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(17,24,39,.90);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      pointer-events:auto;
    }
    .taskBar{ height:8px; border-radius:999px; background: rgba(255,255,255,.08); overflow:hidden; margin-bottom:10px; }
    .taskBarFill{ height:100%; width:100%; border-radius:999px; background: rgba(34,197,94,.78); }
    .taskTitle{ font-weight:950; font-size:16px; color: rgba(234,240,255,.92); margin-bottom:6px; }
    .taskPrompt{ color: rgba(234,240,255,.72); font-size:14px; line-height:1.25; margin-bottom:12px; }
    .taskBtns{ display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; }
    .taskBtn{
      padding:12px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(234,240,255,.90);
      font-weight:900;
      font-size:13px;
      line-height:1.1;
      min-height:48px;
    }
    .taskBtn:active{ transform: translateY(1px); }
    @media (max-width: 380px){
      .taskBtns{ grid-template-columns: 1fr; }
    }


    /* 12.5 Header quality pill */
    .qualityPill{
      padding:4px 10px;
      border-radius:999px;
      font-weight:900;
      font-size:13px;
      background:rgba(16,185,129,.18);
      color:#34d399;
      border:1px solid rgba(52,211,153,.35);
    }

    /* 12.5: ensure task sheet always wins over toasts */
    #taskSheet{ z-index: 90; }
    .qualityFloat{display:none !important;}

        /* 13.2: compact fixed toast zone under stats (doesn't move playfield) */
    #toastZoneWrap{position:fixed; left:0; right:0; top:var(--toastZoneTop, 140px); z-index:65; pointer-events:none;}
    #toastZone{margin:0 12px; display:flex; flex-direction:column; gap:8px; align-items:stretch;
      max-width:720px; margin-left:auto; margin-right:auto;
    }
    .zoneToast{pointer-events:auto; border-radius:16px; padding:10px 12px;
      background:rgba(10,16,28,.72); border:1px solid rgba(140,170,230,.18);
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 12px 30px rgba(0,0,0,.26);
      transform: translateY(-6px); opacity:0; transition: opacity .18s ease, transform .18s ease;
    }
    .zoneToast.show{opacity:1; transform: translateY(0);}
    .zoneToast .tTitle{font-weight:900; letter-spacing:.2px; margin-bottom:4px; font-size:13px; opacity:.88;}
    .zoneToast .tText{opacity:.95; line-height:1.25; font-size:13px;}

    /* 13.0: micro toast in play area (keeps "toast feel" without blocking stats) */
    #microToast{position:absolute; right:14px; top:14px; z-index:40; pointer-events:none;
      max-width:min(240px, calc(100% - 28px));
      padding:8px 10px; border-radius:999px;
      background:rgba(10,16,28,.66); border:1px solid rgba(140,170,230,.16);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 10px 26px rgba(0,0,0,.22);
      opacity:0; transform: translateY(-6px); transition: opacity .16s ease, transform .16s ease;
      font-weight:700; font-size:13px; letter-spacing:.2px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    #microToast.show{opacity:1; transform: translateY(0);}

    /* 13.5: UI-only hides (keep all logic) */
    #btnShare, #btnReset { display:none !important; pointer-events:none !important; }
    /* Common stat ids/classes (safe: only hides visuals) */
    #statTime, #statScore, .statTime, .statScore, .stat--time, .stat--score,
    #time, #score, .time, .score { display:none !important; }
    /* Productivity */
    #productivity, #prodWrap, #prodBar, .productivity, .prodWrap, .prodBar, .stat--productivity { display:none !important; }

    /* 13.6: extra safety hide (JS hides by label) */
    [data-stat="time"], [data-stat="score"], [data-stat="productivity"] { display:none !important; }

    /* 13.7: hard hide for time/score/productivity ids */
    #timeVal, #scoreVal, #prodVal, #prodBar { display:none !important; }

    /* 13.8: Stats grid = 4 tiles (Qualit√§t, Systeme, Datens√§tze, Dubletten) */
    #hudWrap .stats, .hud .stats, .hudStats, #stats {
      grid-template-columns: repeat(4, minmax(0,1fr)) !important;
    }
    /* Hide tiles 5+ in any stats grid */
    #hudWrap .stats > *:nth-child(n+5),
    .hud .stats > *:nth-child(n+5),
    .hudStats > *:nth-child(n+5),
    #stats > *:nth-child(n+5) {
      display:none !important;
    }

    /* 13.9: prune stat labels + ensure only 4 allowed tiles */
    #hudWrap .stats .label, #hudWrap .stats .statLabel, #hudWrap .stats .stat-label, #hudWrap .stats .k,
    .hud .stats .label, .hud .stats .statLabel, .hud .stats .stat-label, .hud .stats .k {
      display:none !important;
    }
    #hudWrap .stats > :nth-child(-n+4) .label,
    #hudWrap .stats > :nth-child(-n+4) .statLabel,
    #hudWrap .stats > :nth-child(-n+4) .stat-label,
    #hudWrap .stats > :nth-child(-n+4) .k,
    .hud .stats > :nth-child(-n+4) .label,
    .hud .stats > :nth-child(-n+4) .statLabel,
    .hud .stats > :nth-child(-n+4) .stat-label,
    .hud .stats > :nth-child(-n+4) .k {
      display:block !important;
    }

    
    /* 14.4: Zen button (toolbar) */
    #btnZen.ghost{
      border-color: rgba(100,133,193,.45) !important;
      background: rgba(100,133,193,.10) !important;
    }
    #btnZen.ghost:hover{
      background: rgba(100,133,193,.16) !important;
    }

    /* 14.5: keep HUD minimal (only 4 stat tiles) */
    .hud > .stat:nth-child(n+5){ display:none !important; }
    /* 14.5: hide remaining time/score/productivity elements defensively */
    #timeVal,#scoreVal,#prodVal,#prodBar,#timerPill,[data-stat="time"],[data-stat="score"],[data-stat="productivity"]{
      display:none !important;
    }
</style>

</head>
<body>
  <div class="wrap">
    <button id="hudToggle" class="hudToggle" type="button" aria-label="Bereich ein-/ausklappen">
      <span class="hudToggleLeft">
        <span class="hudTitle">Love your Data</span>
        <span id="hudLevelTiny" class="hudLevelTiny">Level</span> 
      </span>
      <span class="hudChevron">‚ñæ</span>
    </button>

    <div id="hudWrap" class="hudWrap">

    <header>
      <div class="brand">
        <div class="t">
          Love your Data
          <span class="pill"><span class="dot"></span><span id="lvlLbl">Level 1</span></span>
          <span id="mdmPill" class="pill mdm" style="display:none;"><span class="dot"></span>MDM aktiv</span>
          <span id="timerPill" class="pill" style="display:none;">
            <span class="dot" style="background:rgba(255,255,255,.25); box-shadow:0 0 0 3px rgba(255,255,255,.08)"></span>
            <span id="timerLbl">120s</span>
          </span>
        </div>
        <div class="sub">
          Fixe Fehler. Merge Dubletten. üíô
        </div>
      </div>

      <div class="actions">
        <button id="btnPrev">‚óÄÔ∏é</button>
        <button id="btnNext" class="primary">Next ‚ñ∂Ô∏é</button>
        <button id="btnMdm" class="primary">MDM: Off</button>
        <button id="btnHeal" class="primary" style="display:none;">Stammdatenfehler beheben</button>
        <button id="btnSession" class="ghost">Session: On</button>
        <button id="btnDemo" class="ghost">Demo: Off</button>
        <button id="btnZen" class="ghost" title="Zen Game">üßò Zen</button>
        <button id="btnShare" class="primary">Share</button>
        <button id="btnReset" class="danger">Reset</button>
      </div>
    </header>

    <div class="hud">
      <div class="stat">
        <div class="k">Qualit√§t</div>
        <div class="v"><span id="qVal">100</span>%</div>
        <div class="bar"><i id="qBar" style="width:100%"></i></div>
      </div>
      <div class="stat">
        <div class="k">Systeme</div>
        <div class="v" id="sysVal">1</div>
        <div class="k" style="margin-top:2px;">Replikation</div>
        <div class="v" id="spreadVal">niedrig</div>
      </div>
      <div class="stat">
        <div class="k">Datens√§tze</div>
        <div class="v" id="recVal">10</div>
        <div class="k" style="margin-top:2px;">Fehler (rot)</div>
        <div class="v" id="errVal">0</div>
      </div>
      <div class="stat">
        <div class="k">Dubletten (orange)</div>
        <div class="v" id="dupVal">0</div>
        <div class="k" style="margin-top:2px;">Fixes</div>
        <div class="v" id="fixVal">0</div>
      </div>
      <div class="stat">
        <div class="k">Kosten</div>
        <div class="v" id="costVal">0 ‚Ç¨</div>
        <div class="k" style="margin-top:2px;">Zeit</div>
        <div class="v" id="timeVal">0.0</div>
      </div>
      <div class="stat">
        <div class="k">Score (Session)</div>
        <div class="v" id="scoreVal">0</div>
        <div class="k" style="margin-top:2px;">Produktivit√§t</div>
        <div class="v"><span id="prodVal">100</span>%</div>
        <div class="bar"><i id="prodBar" style="width:100%"></i></div>
      </div>
    </div>
</div><!-- /hudWrap -->

    <!-- Toast Zone (fixed by layout) -->
    <div id="toastZoneWrap">
      <div id="toastZone"></div>
    </div>





    <div class="stage" id="stage">
      <canvas id="c"></canvas>
      <div id="microToast" aria-live="polite"></div>
      
  <!-- Task Bot
tom Sheet (12.5) -->
  <div id="taskSheet" class="taskSheet" style="display:none;">
    <div class="taskBar"><div id="taskBarFill" class="taskBarFill"></div></div>
    <div class="taskTitle" id="taskTitle">‚òéÔ∏è Task</div>
    <div class="taskPrompt" id="taskPrompt">‚Ä¶</div>
    <div class="taskBtns" id="taskBtns"></div>
  </div>

<div id="toast" class="toastWrap" style="display:none;"><div class="toastCard" style="opacity:0;"><div class="toastHead"></div><div class="toastBody"></div></div></div>
    </div>
  </div>

  <script>
    
function on(id, evt, fn){ const e=document.getElementById(id); if(e) e.addEventListener(evt, fn); }
// =========================
    // Utilities
    // =========================
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp  = (a,b,t)=>a+(b-a)*t;
    const rnd   = (a,b)=>a+Math.random()*(b-a);
    const now   = ()=>performance.now();
    const el = (id)=>document.getElementById(id);

    // HUD collapse / expand (11.3)
    function syncHudTiny(){
      const lvl = LEVELS[game.lvlIndex] || {name:""};
      const t = el("hudLevelTiny");
      if(t) t.textContent = `Level ${game.lvlIndex+1}: ${lvl.name||""}`.trim();
    }
    function setHudCollapsed(collapsed){
      game.hudCollapsed = !!collapsed;
      document.body.classList.toggle("hudCollapsed", game.hudCollapsed);
      try{ localStorage.setItem("lyd_hudCollapsed", game.hudCollapsed ? "1":"0"); }catch(e){}
    }
    function toggleHud(){ setHudCollapsed(!game.hudCollapsed); }

    function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }
    function fmtEuro(n){ const v = Math.round(n); return v.toLocaleString("de-DE") + " ‚Ç¨"; }
    function qualityColor(q){ if(q>=80) return getCSS("--good"); if(q>=55) return getCSS("--warn"); return getCSS("--bad"); }
    function stars(n){ return "‚òÖ".repeat(n) + "‚òÜ".repeat(5-n); }

    // =========================
    // Canvas setup
    // =========================
    const canvas = document.getElementById("c");
    const stage  = document.getElementById("stage");
    const ctx    = canvas.getContext("2d", { alpha: true });

    // =========================
    // Content
    // =========================
    const SYSTEM_LABELS = [
      ["ERP"],
      ["ERP","CRM","Shop"],
      ["ERP","CRM","Shop","WMS","BI","Finance"],
      ["ERP","CRM","Shop","WMS","BI","Support","Finance","PIM","DataLake"],
      ["ERP","CRM","Shop","WMS","BI","Support","Finance","PIM","DataLake"]
    ];

    const SYSTEM_INFO = {
      "ERP":     { title:"ERP",      text:"Entstehung & Pflege von Stammdaten.", impact:"Fix hier = Ursache weg, wirkt in allen Folgesystemen." },
      "CRM":     { title:"CRM",      text:"Kundenpflege & Service-Kontext.",      impact:"Dubletten hier ‚Üí Kunde wird nicht erkannt." },
      "Shop":    { title:"Shop",     text:"Checkout nutzt replizierte Daten.",   impact:"Lokalfix m√∂glich ‚Äì aber Ursprung bleibt falsch." },
      "WMS":     { title:"WMS",      text:"Versand nutzt replizierte Daten.",    impact:"Lokalfix teuer; Fehler kann zur√ºckkommen." },
      "BI":      { title:"BI",       text:"Reports aggregieren replizierte Daten.", impact:"Falsche KPIs ‚Üí falsche Entscheidungen." },
      "Finance": { title:"Finance",  text:"Abrechnung nutzt replizierte Daten.", impact:"Fehler sp√§t = Reklamationen & Aufwand." },
      "Support": { title:"Support",  text:"Tickets brauchen saubere IDs.",       impact:"Kunde nicht auffindbar ‚Üí Frust." },
      "PIM":     { title:"PIM",      text:"Produktstammdaten als Quelle.",       impact:"Inkonsistent ‚Üí falsche Infos im Shop." },
      "DataLake":{ title:"Data Lake",text:"Zentrale Datenbasis.",               impact:"Garbage in ‚Üí Garbage out." }
    };

    const TASK_DURATION_MS = 4000;
    const DEMO_TASK_DURATION_MS = 3000;

    const TASK_BANK = [
      {
        icon:"üìû",
        title:"Anruf vom Kundenservice",
        prompt:"Kunde ist aufgebracht. Was machst du zuerst?",
        options:[
          {label:"Ticket anlegen", ok:true},
          {label:"Sp√§ter zur√ºckrufen", ok:false},
          {label:"Weiterleiten", ok:false}
        ]
      },
      {
        icon:"üì¶",
        title:"Versandproblem",
        prompt:"Lieferadresse passt nicht zum Kunden. Aktion?",
        options:[
          {label:"Adresse verifizieren", ok:true},
          {label:"Einfach schicken", ok:false},
          {label:"Stornieren", ok:false}
        ]
      },
      {
        icon:"üí¨",
        title:"R√ºckfrage Finance",
        prompt:"Zahlungsdaten unklar. Wie reagierst du?",
        options:[
          {label:"Stammdatensatz pr√ºfen", ok:true},
          {label:"Sch√§tzen & buchen", ok:false},
          {label:"Ignorieren", ok:false}
        ]
      }
    ];

    const IMPACTS_DUP = [
      { stars: 2, text: "Ich existiere doppelt ‚Äì Support findet meinen Vorgang nicht.", area:"Support", cost:[220, 800], score:-110 },
      { stars: 2, text: "Doppelte Rechnung ‚Äì bitte kl√§ren!", area:"Finance", cost:[260, 950], score:-130 },
      { stars: 1, text: "Zwei Kundenkonten ‚Äì Punkte & Historie sind weg.", area:"CRM", cost:[180, 650], score:-85 },
      { stars: 2, text: "Falsche Zuordnung wegen Dublette.", area:"Shop/WMS", cost:[240, 1000], score:-120 }
    ];

    const IMPACTS = [
      { stars: 1, text: "Bestellung nie angekommen.", area: "Versand",       cost: [350, 900],  score: -120 },
      { stars: 2, text: "Rechnung falsch ‚Äì muss ich wieder hinterherlaufen?", area:"Finance",   cost: [220, 700],  score: -90 },
      { stars: 1, text: "Adresse war korrekt ‚Äì warum an Nachbarn geliefert?", area:"CRM/Ship", cost: [280, 1100], score: -140 },
      { stars: 2, text: "Doppelter Kundenstamm: Support findet mich nicht.",  area:"Support",  cost: [180, 650],  score: -80 },
      { stars: 1, text: "Retouren-Chaos wegen falscher Artikelstammdaten.",   area:"Shop/WMS", cost: [300, 1300], score: -150 },
      { stars: 3, text: "Lieferung versp√§tet, Status stimmt nicht.",          area:"Tracking", cost: [120, 420],  score: -45 }
    ];

    const LEVELS = [
      // L1: no incidents by design (single system)
      { id:1, name:"First Date (Tutorial)", systems:1, records:10, baseErrorRate:0.012, duplicateRate:0.000, replRate:0.00, costPerBadPerSec:0.25, timeWeight:1.0, sessionLen:60.0, incidents:false },
      { id:2, name:"Offene Beziehung",     systems:3, records:18, baseErrorRate:0.020, duplicateRate:0.012, replRate:0.75, costPerBadPerSec:1.8, timeWeight:1.15, sessionLen:90.0, incidents:true  },
      { id:3, name:"Commitment Issues",    systems:6, records:28, baseErrorRate:0.028, duplicateRate:0.020, replRate:0.85, costPerBadPerSec:3.2, timeWeight:1.35, sessionLen:90.0, incidents:true  },
      { id:4, name:"Toxisch",              systems:9, records:40, baseErrorRate:0.034, duplicateRate:0.026, replRate:0.92, costPerBadPerSec:4.6, timeWeight:1.65, sessionLen:90.0, incidents:true  },
      { id:5, name:"True Love (MDM)",      systems:9, records:40, baseErrorRate:0.016, duplicateRate:0.006, replRate:0.62, costPerBadPerSec:1.0, timeWeight:0.95, forceMdm:true, sessionLen:90.0, incidents:true }
    ];

    class Record{
      constructor(x,y){
        this.x=x; this.y=y;
        this.vx=rnd(-18,18); this.vy=rnd(-18,18);
        this.r=11;
        this.state="good"; // good | bad | dupA | dupB
        this.originSys=0;  // stays here
        this.repTo=0;      // replicated up to system index
        this.localFixTo=-1; // local patch up to sys index (ghost fix), origin still wrong
        this.localMergeTo=-1; // local mapping/merge in downstream, origin still duplicated
        this.id = Math.random().toString(16).slice(2);
        this.link=null;
        this.jitter=rnd(0,1000);
      }
    }

    // =========================
    // State
    // =========================
    const game = {
      viewport:{w:0,h:0},
      dpr:1,
      lvlIndex:0,
      mdm:false,
      systems:[],
      records:[],
      metrics:{quality:100, errors:0, dups:0, fixes:0, cost:0, timeSpent:0, score:0},

      sessionOn:true,
      sessionLen:120.0,
      sessionLeft:120.0,
      sessionState:"live",

      demo:{ on:false, nextActionIn:1.0, autoRestartIn:2.2 },

      tutorial:{ active:false, step:0 },
      tutorialImpactDone:false,

      task:null,          // active minigame task
      taskUntil:0,
      taskRects:[],       // hitboxes for task options

      nextImpactIn:7.5,
      nextEventIn:7.0,

      systemPopup:{ active:false, x:0, y:0, data:null, until:0 },

      toastAt:0,
      toastCooldownUntil:0,
      help:{ seenGhostTip:false }
    };

    let baseline = { taken:false, mdmState:false, quality:0, cost:0, score:0 };
    function snapshotBaseline(){
      baseline = {
        taken:true,
        mdmState: game.mdm,
        quality: Math.round(game.metrics.quality),
        cost: Math.round(game.metrics.cost),
        score: Math.round(game.metrics.score)
      };
    }

    function toast(text, kind="info", ttl=2.8, once=false){
      if(once){ if(seenToasts.has(text)) return; seenToasts.add(text); }
      const zone = document.getElementById('toastZone');
      if(!zone) return;
      const el = document.createElement('div');
      el.className = 'zoneToast';
      const title = "Info";
      el.innerHTML = `<div class=\"tTitle\">${title}</div><div class=\"tText\">${String(text).includes('<') ? text : escapeHtml(text)}</div>`;
      zone.appendChild(el);
      // 13.0: micro toast in play area
      try{
        const mt = document.getElementById('microToast');
        if(mt){
          const short = String(text).replace(/<[^>]+>/g,'').replace(/\s+/g,' ').trim();
          mt.textContent = short.length>46 ? short.slice(0,43)+'‚Ä¶' : short;
          mt.classList.add('show');
          clearTimeout(mt._t);
          mt._t = setTimeout(()=> mt.classList.remove('show'), 1400);
        }
      }catch(e){}

      // keep only last 2
      while(zone.children.length>2) zone.removeChild(zone.firstChild);
      requestAnimationFrame(()=> el.classList.add('show'));
      setTimeout(()=>{
        el.classList.remove('show');
        setTimeout(()=>{ try{ el.remove(); }catch(e){} }, 220);
      }, Math.max(1200, ttl*1000));
    }


    // =========================
    // Layout
    // =========================
    function resize(){
      const bw = document.querySelector('.boardWrap') || document.body;
      const availW = Math.max(280, bw.clientWidth - 24);
      const r = stage.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2.25, window.devicePixelRatio || 1));
      canvas.width = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      canvas.style.width = r.width + "px";
      canvas.style.height = r.height + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
      game.viewport.w = r.width;
      game.viewport.h = r.height;
      game.dpr = dpr;
    }
    window.addEventListener("resize", resize);

    function buildSystems(n){
      const W = game.viewport.w, H = game.viewport.h;
      const pad = 64;

      const labels = (SYSTEM_LABELS[game.lvlIndex] || []).slice(0,n);
      const baseR = clamp(Math.min(46, Math.max(34, W*0.055)), 34, 46);

      // 12.5: grid layout on small screens for many systems (less cramped)
      const useGrid = (W <= 520 && n >= 7);

      if(useGrid){
        const cols = 3;
        const rows = Math.ceil(n/cols);
        const gx0 = pad;
        const gx1 = W - pad;
        const gy0 = H*0.25;
        const gy1 = H*0.60;
        const xs = [];
        for(let i=0;i<n;i++){
          const c = i % cols;
          const r = Math.floor(i/cols);
          const x = lerp(gx0, gx1, cols===1 ? 0.5 : c/(cols-1));
          const y = lerp(gy0, gy1, rows===1 ? 0.5 : r/(rows-1));
          // small jitter to avoid perfect stacking
          xs.push({x: x + rnd(-10,10), y: y + rnd(-8,8)});
        }
        return xs.map((p,i)=>({ x:p.x, y:p.y, r:baseR, idx:i, label: labels[i] || ("SYS "+(i+1)) }));
      }

      // default: curved line
      const xs=[];
      if(n===1) xs.push(W*0.5);
      else for(let i=0;i<n;i++) xs.push(lerp(pad, W-pad, i/(n-1)));

      const yBase = H*0.33;
      const yAmp  = Math.min(110, H*0.18);

      return xs.map((x,i)=>{
        const phase = (i/(Math.max(1,n-1))) * Math.PI * 1.2;
        const y = yBase + Math.sin(phase) * yAmp;
        return { x, y, r: baseR, idx:i, label: labels[i] || ("SYS "+(i+1)) };
      });
    }

    // =========================
    // Metrics
    // =========================
    function effectiveStateAtSys(r, sysIdx){
      // Downstream patches can mask symptoms, but don't clean origin truth.
      if(r.localFixTo >= sysIdx) return "good";
      if(r.localMergeTo >= sysIdx && (r.state==="dupA" || r.state==="dupB")) return "good";
      return r.state;
    }


    function incidentSignal(){
      // incidents should be driven by actually *used* faulty data in downstream systems
      let badLate=0, dupLate=0;
      for(const r of game.records){
        if(r.repTo >= 2){
          if(r.state==="bad") badLate++;
          if(r.state==="dupA" || r.state==="dupB") dupLate++;
        }
      }
      return { badLate, dupLate, late: badLate + dupLate };
    }

    function computeQuality(){
      // quality should reflect "real world": upstream truth is what matters most, but patched late helps a bit
      let bad=0, dup=0, patched=0, mapped=0;
      for(const r of game.records){
        if(r.state==="bad") bad++;
        if(r.state==="dupA" || r.state==="dupB") dup++;
        if(r.localFixTo >= 2) patched++;
        if(r.localMergeTo >= 2) mapped++;
      }
      const total = game.records.length || 1;

      // base penalty from truth
      let q = 100 - (bad/total)*62 - (dup/total)*52;

      // small relief if many late local patches / dedupe mappings exist (still not great)
      q += (patched/total)*10;
      q += (mapped/total)*8;

      q = clamp(q, 0, 100);
      game.metrics.errors = bad;
      game.metrics.dups = Math.floor(dup/2);
      game.metrics.quality = q;
    }

    function replLabel(){
      const L = LEVELS[game.lvlIndex];
      const s = L.replRate * (game.mdm ? 0.45 : 1.0);
      if(s < 0.55) return "niedrig";
      if(s < 0.85) return "mittel";
      return "hoch";
    }

    function updateHUD(){
      computeQuality();
      const m = game.metrics;
      const q = m.quality;

      el("qVal").textContent = String(Math.round(q));
      const bar = el("qBar");
      bar.style.width = `${q}%`;
      bar.style.background = qualityColor(q);

      el("sysVal").textContent = String(LEVELS[game.lvlIndex].systems);
      el("recVal").textContent = String(LEVELS[game.lvlIndex].records);
      el("errVal").textContent = String(m.errors);
      el("dupVal").textContent = String(m.dups);
      el("fixVal").textContent = String(m.fixes);
      el("costVal").textContent = fmtEuro(m.cost);
      el("timeVal").textContent = m.timeSpent.toFixed(1);
      el("spreadVal").textContent = (LEVELS[game.lvlIndex].systems < 2) ? "‚Äî" : replLabel();

      el("scoreVal").textContent = String(Math.round(m.score));
      // Produktivit√§t: grob (weniger Tasks/Incidents + hohe Qualit√§t). Mit MDM typischerweise h√∂her.
      const baseProd = m.quality;
      const taskPenalty = game.task ? 18 : 0;
      const mdmBonus = game.mdm ? 10 : 0;
      const prod = clamp(baseProd - taskPenalty + mdmBonus, 0, 100);
      el("prodVal").textContent = String(Math.round(prod));
      const pb = el("prodBar");
      pb.style.width = `${prod}%`;
      pb.style.background = qualityColor(prod);
      if(game.sessionOn) el("timerLbl").textContent = `${Math.ceil(game.sessionLeft)}s`;
    }

    // =========================
    // Tutorial
    // =========================
    function tutorialStartIfLevel1(){
      const L = LEVELS[game.lvlIndex];
      if(L.id !== 1){ game.tutorial.active=false; return; }
      game.tutorial.active=true;
      game.tutorial.step=0;
      game.tutorialImpactDone=false;
      
    }

    function tutorialTick(){
      if(!game.tutorial.active) return;
      switch(game.tutorial.step){
        case 0:
          game.records.forEach((r,i)=>{ r.state=(i===0?"bad":"good"); r.link=null; r.repTo=0; r.localFixTo=-1; });
          
          game.tutorial.step=1;
          break;
        case 1:
          if(game.metrics.errors===0){
            
            game.tutorial.step=2;
          }
          break;
        case 2:
          if(!game.task){
            spawnTask(true);
            
          }
          game.tutorial.step=3;
          break;
        case 3:
          if(!game.task){
            toast("Weiter mit Level 2: Replikation + sp√§te Kosten.", "Tutorial");
            game.tutorial.active=false;
          }
          break;
      }
    }

    // =========================
    // Tasks: Minigame over data
    // =========================
    const seenToasts = new Set();

    function canSpawnTask(force=false){
      if(game.sessionOn && game.sessionState==="ended") return false;
      if(game.task) return false;
      if(now() < (game.nextTaskAt||0)) return false;
      return true;
    }

    function spawnTask(force=false){
      const L = LEVELS[game.lvlIndex];
      if(!canSpawnTask(force)) return;
// In Level 1: allow tutorial task. In others: random
      if(!force){
        // probability tuned for not-too-annoying
        const p = (game.mdm ? 0.035 : 0.055);
        if(Math.random() > p) return;
        // avoid spawning if chaos is already high
        if(game.metrics.quality < 35 && Math.random() < 0.6) return;
      }

      const t = TASK_BANK[(Math.random()*TASK_BANK.length)|0];
      // clone and shuffle options
      const opts = [...t.options].sort(()=>Math.random()-0.5);
      game.task = {
        icon:t.icon,
        title:t.title,
        prompt:t.prompt,
        options:opts,
        // position in canvas space
        x: rnd(game.viewport.w*0.32, game.viewport.w*0.68),
        y: rnd(game.viewport.h*0.48, game.viewport.h*0.78),
      };
      // keep task panel fully visible (mobile-safe)
      (function(){
        const boxH = 150;              // approx height of task panel including buttons
        const extraBottom = (window.innerWidth <= 520) ? 130 : 60; // room for bottom UI / safe-area
        const minY = 50;
        const maxY = Math.max(minY, game.viewport.h - boxH - extraBottom);
        game.task.y = Math.max(minY, Math.min(game.task.y, maxY));

        const boxW = Math.min(460, game.viewport.w*0.92);
        const minX = boxW*0.50;
        const maxX = Math.max(minX, game.viewport.w - boxW*0.50);
        game.task.x = Math.max(minX, Math.min(game.task.x, maxX));
      })();

      game.taskUntil = now() + (game.demo.on ? DEMO_TASK_DURATION_MS : TASK_DURATION_MS);
      // 12.5: nextTaskAt is handled centrally on task end (cooldown)
game.taskRects = [];
    }

    function resolveTask(ok){
      if(!game.task) return;
      if(ok){
        game.metrics.score += 40;
        if(game.mdm && Math.random() < 0.35){
          toast(`üëç Sauberer Prozess ‚Äì MDM verhindert Folgefehler.`, "MDM");
        } else {
          
        }
      } else {
        // penalty: short burst of background decay / replication boost
        game.metrics.score -= 30;
        game.metrics.cost += 80 + (LEVELS[game.lvlIndex].systems*18);
        
        // inject 1-2 new upstream errors to simulate distraction
        const n = 1 + (Math.random()<0.20 ? 1 : 0);
        for(let i=0;i<n;i++){
          const r = game.records.find(x=>x.state==="good" && x.repTo<=1);
          if(r) r.state="bad";
        }
      }
      game.task = null;
      // 12.5: extra cooldown for tasks in MDM mode
      if(game.mdm){ game.nextTaskAt = now() + 7.0; }

      game.taskRects = [];
      game.taskUntil = 0;
    }

    // 12.5: Task UI as bottom sheet (mobile-first)
    function renderTaskSheet(){
      const sheet = el("taskSheet");
      if(!sheet) return;

      // only show when a task is active and session is live (if session enabled)
      const active = !!(game.task && (game.sessionOn ? game.sessionState==="live" : true));
      if(!active){
        sheet.style.display = "none";
        return;
      }

      const t = game.task;
      sheet.style.display = "block";

      // title/prompt
      const title = el("taskTitle");
      const prompt = el("taskPrompt");
      if(title) title.textContent = `${t.icon} ${t.title}`;
      if(prompt) prompt.textContent = t.prompt;

      // progress bar
      const dur = (game.demo.on ? DEMO_TASK_DURATION_MS : TASK_DURATION_MS);
      const frac = clamp((game.taskUntil - now()) / dur, 0, 1);
      const fill = el("taskBarFill");
      if(fill){
        fill.style.width = (frac*100).toFixed(1) + "%";
        fill.style.background = (frac>0.34) ? "rgba(34,197,94,.78)" : "rgba(239,68,68,.78)";
      }

      // buttons
      const btns = el("taskBtns");
      if(btns && !btns.dataset.bound){
        btns.dataset.bound = "1";
        btns.addEventListener("click", (e)=>{
          const b = e.target.closest("button[data-ok]");
          if(!b) return;
          const ok = b.dataset.ok === "1";
          resolveTask(ok);
        });
      }
      if(btns){
        btns.innerHTML = t.options.map((o)=>(
          `<button class="taskBtn" data-ok="${o.ok?1:0}" type="button">${escapeHtml(o.label)}</button>`
        )).join("");
      }
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function hideHudFields(){
      const hud = document.querySelector('#hudWrap .hud');
      if(!hud) return;
      const kill = ["zeit","time","score","punkte","produktivit√§t","productivity"];
      const nodes = Array.from(hud.querySelectorAll('*'));
      for(const n of nodes){
        const t = (n.textContent||"").trim().toLowerCase();
        if(!t) continue;
        if(kill.some(k=> t === k || t.startsWith(k) || t.includes(" "+k) || t.includes("\n"+k))){
          let p = n;
          for(let i=0;i<5 && p && p !== hud;i++){
            if(p.classList && (p.classList.contains('stat') || p.classList.contains('statItem') || p.classList.contains('hudItem') || p.classList.contains('kv') || p.classList.contains('hudCell'))) break;
            p = p.parentElement;
          }

    function hideExtraHudRows(){
      // Hide the label/value pairs for Zeit, Score, Produktivit√§t (keep other stats)
      const pairs = [
        {kText:"Zeit", vId:"timeVal"},
        {kText:"Score (Session)", vId:"scoreVal"},
        {kText:"Produktivit√§t", vId:"prodVal"},
      ];
      for(const p of pairs){
        const v = document.getElementById(p.vId);
        if(v){
          // value container
          v.style.display = "none";
          // label is usually previous sibling .k
          const k = v.previousElementSibling;
          if(k && k.classList && k.classList.contains('k')) k.style.display="none";
          // if the label isn't direct sibling, search within same .stat
          const stat = v.closest('.stat');
          if(stat){
            const ks = Array.from(stat.querySelectorAll('.k'));
            for(const kk of ks){
              if((kk.textContent||"").trim() === p.kText) kk.style.display="none";
            }
          }
        } else {
          // hide by text within HUD if id missing
          const hud = document.querySelector('#hudWrap .hud');
          if(hud){
            for(const kk of hud.querySelectorAll('.k')){
              if((kk.textContent||"").trim() === p.kText) kk.style.display="none";
            }
          }
        }
      }
      // Hide productivity bar container if present
      const pb = document.getElementById('prodBar');
      if(pb){
        const bar = pb.closest('.bar');
        if(bar) bar.style.display = "none";
      }
      // Optionally remove the whole Score stat tile if it becomes empty-ish
      const scoreVal = document.getElementById('scoreVal');
      if(scoreVal){
        const stat = scoreVal.closest('.stat');
        if(stat){
          // if it only contains hidden nodes, hide whole tile
          const visible = Array.from(stat.querySelectorAll('*')).some(n=> getComputedStyle(n).display !== 'none' && (n.textContent||'').trim().length);
          // still keep the tile if Systeme etc (not the case)
          if(!visible) stat.style.display="none";
        }
      }
    }
          if(p && p !== hud) p.style.display = 'none';
        }
      }
    }

    // =========================
    // Impacts / Incidents
    // =========================
    function triggerImpact(reasonTag){
      const damp = game.mdm ? 0.35 : 1.0;
      const imp = IMPACTS[(Math.random()*IMPACTsLen)|0];
      const spike = (imp.cost[0] + Math.random()*(imp.cost[1]-imp.cost[0])) * damp;

      game.metrics.cost += spike;
      game.metrics.score += Math.round(imp.score * damp);

      toast(`${stars(imp.stars)} <b>${imp.text}</b> <span class="tag">${imp.area}</span> <span class="tag">+${fmtEuro(spike)}</span>`, reasonTag || "Impact");
    }
    const IMPACTsLen = IMPACTS.length;

    function lateExposureSignal(){
      const L = LEVELS[game.lvlIndex];
      const last = Math.max(0, L.systems-1);
      const lateThreshold = Math.max(2, Math.floor(last * 0.7));

      let bad=0, dup=0;
      for(const r of game.records){
        if(r.repTo >= lateThreshold){
          // evaluate state AT late system (patched replicas count as good)
          const st = effectiveStateAtSys(r, lateThreshold);
          if(st==="bad") bad++;
          if(st==="dupA"||st==="dupB") dup++;
        }
      }
      return { badLate: bad, dupLate: dup, lateThreshold };
    }

    function maybePropagationEvent(dt){
      const L = LEVELS[game.lvlIndex];
      if(!L.incidents) return;
      if(game.sessionOn && game.sessionState!=="live") return;

      // Signal gating: no faulty downstream usage -> no incidents.
      const sig = incidentSignal();
      if(sig.late <= 0) return;

      // Quality damping: the cleaner the data, the rarer incidents.
      const q = computeQuality();
      const qualityDamp = clamp((100 - q) / 40, 0, 1); // 100->0, 60->1

      // With MDM and decent quality: incidents are exception.
      if(game.mdm && q > 85) return;

      game.nextEventIn -= dt;
      if(game.nextEventIn > 0) return;

      // Base interval depends on MDM + current signal
      const lateFactor = clamp(sig.late / Math.max(10, game.records.length*0.12), 0.2, 1.0);
      const mdmMul = game.mdm ? 2.6 : 1.0;
      game.nextEventIn = (8.5 + Math.random()*8.0) * mdmMul * (1.2 - 0.5*lateFactor);

      // Probability to actually fire now
      const p = clamp((0.18 + lateFactor*0.45) * qualityDamp * (game.mdm ? 0.10 : 1.0), 0, 0.75);
      if(Math.random() > p) return;

      // Pick a system focus
      const sysIdx = 2 + ((Math.random() * Math.max(1, game.systems.length-2))|0);
      const sys = game.systems[sysIdx];
      const isDup = (sig.dupLate > sig.badLate) && (Math.random() < 0.6);
      const kind = isDup ? "Dublette" : "Fehler";

      const cost = Math.round((120 + Math.random()*220) * (game.mdm ? 0.55 : 1.0) * (0.8 + lateFactor*0.6));
      game.metrics.cost += cost;
      game.metrics.score -= Math.round((45 + lateFactor*35) * (game.mdm ? 0.55 : 1.0));

      toast(`‚ö†Ô∏è Incident in <b>${sys?.label || "Folgesystem"}</b> ‚Äî ${kind} wird genutzt <span class="tag">+${fmtEuro(cost)}</span>`, "Incident");
    }

    function maybeImpact(dt){
      const L = LEVELS[game.lvlIndex];
      if(!L.impacts) return;
      if(game.sessionOn && game.sessionState!=="live") return;

      const sig = incidentSignal();
      if(sig.late <= 0) return;

      const q = computeQuality();
      const qualityDamp = clamp((100 - q) / 40, 0, 1);

      if(game.mdm && q > 85) return;

      game.nextImpactIn -= dt;
      if(game.nextImpactIn > 0) return;

      // schedule next check
      const lateFactor = clamp(sig.late / Math.max(10, game.records.length*0.12), 0.2, 1.0);
      const mdmMul = game.mdm ? 2.8 : 1.0;
      game.nextImpactIn = (10.5 + Math.random()*10.0) * mdmMul * (1.25 - 0.55*lateFactor);

      const taskBoost = game.task ? 0.08 : 0;
      const p = clamp((0.12 + lateFactor*0.55 + taskBoost) * qualityDamp * (game.mdm ? 0.10 : 1.0), 0, 0.85);
      if(Math.random() > p) return;

      const useDup = (sig.dupLate > sig.badLate) && (Math.random() < 0.75);
      const pool = useDup ? IMPACTS_DUP : IMPACTS;
      const imp = pool[(Math.random()*pool.length)|0];

      const cost = Math.round((imp.cost[0] + Math.random()*(imp.cost[1]-imp.cost[0])) * (game.mdm ? 0.55 : 1.0));
      game.metrics.cost += cost;
      game.metrics.score += imp.score * (game.mdm ? 0.55 : 1.0);

      toast(`‚òÖ${imp.stars} ${imp.text} <span class="tag">+${fmtEuro(cost)}</span>`, imp.area);
    }

    // =========================
    // Simulation
    // =========================
    function spreadTick(dt){
      const L = LEVELS[game.lvlIndex];

      // spawn minigame tasks (even in level 1, but lower)
      if(canSpawnTask(false) && (L.id===1 ? Math.random()<dt*0.04 : true)) spawnTask(false);

      // task timeouts
      if(game.task && now() > game.taskUntil){
        resolveTask(false);
      }

      // Distraction factor: while task is active, more decay + more replication
      const taskFactor = game.task ? 1.18 : 1.0;

      // "Entstehung" stark fr√ºh, Replikation √ºberall
      const errRate  = L.baseErrorRate * (game.mdm ? 0.08 : 1.0) * taskFactor;
      const dupRate  = L.duplicateRate * (game.mdm ? 0.05 : 1.0) * taskFactor;
      const replRate = L.replRate      * (game.mdm ? 0.45 : 1.0) * (game.task ? 1.12 : 1.0);

      // With MDM: errors are prevented/validated at the source, so they don't spread into usage systems.
      const mdmPreventsSpread = !!game.mdm;

      for(const r of game.records){
        const early = (r.repTo <= 1);

        // Replikation nach hinten (keine neue Entstehung dort)
        const advanceProb = replRate * 0.16 * dt;
        if(r.repTo < game.systems.length-1 && Math.random() < advanceProb){
          if(mdmPreventsSpread && r.state !== "good"){
            // validation blocks propagation of faulty data
          } else {
            r.repTo++;
          }
        }

        // New errors mainly early
        if(r.state==="good"){
          const pErr = early ? errRate : errRate * 0.12;
          if(Math.random() < pErr * dt) r.state="bad";
        }

        // Duplicates mainly early
        if(!mdmPreventsSpread && r.state==="good" && early && L.systems>=2 && Math.random() < dupRate * dt){
          const a = r;
          const b = new Record(a.x + rnd(-22,22), a.y + rnd(-22,22));
          b.originSys = a.originSys;
          b.repTo = a.repTo;
          a.state="dupA"; b.state="dupB";
          a.link=b.id; b.link=a.id;
          game.records.push(b);
        }

        if(!game.mdm){
          // local patches/mappings are fragile
          if(r.localFixTo >= 2){
            const frac = r.localFixTo / Math.max(1, (game.systems.length-1));
            const relapse = (0.010 + frac*0.020) * dt * taskFactor;
            if(Math.random() < relapse){
              r.localFixTo = -1;
        r.localMergeTo = -1;
              if(Math.random() < 0.15) toast("Lokalfix wieder da ‚Äì Ursprung unsauber.", "Folgesystem");
            }
          }
          if(r.localMergeTo >= 2){
            const frac = r.localMergeTo / Math.max(1, (game.systems.length-1));
            const relapse = (0.008 + frac*0.016) * dt * taskFactor;
            if(Math.random() < relapse){
              r.localMergeTo = -1;
              if(Math.random() < 0.12) toast("Downstream wieder inkonsistent ‚Äì Dublette bleibt.", "Folgesystem");
            }
          }
        }
      }

      // Upstream contamination (copy/paste/import)
      const infectors = game.records.filter(r => r.state!=="good");
      if(!mdmPreventsSpread && infectors.length){
        const attempts = Math.min(40, infectors.length);
        for(let i=0;i<attempts;i++){
          const src = infectors[(Math.random()*infectors.length)|0];
          const cand = game.records[(Math.random()*game.records.length)|0];
          if(!cand || cand.state!=="good") continue;
          if(cand.repTo > 1) continue; // only early "creation"

          const dx = cand.x - src.x, dy = cand.y - src.y;
          const dist2 = dx*dx + dy*dy;
          const radius = 120;
          const p = 0.06 * dt * (dist2 < radius*radius ? 0.9 : 0.2) * (game.mdm ? 0.45 : 1.0) * taskFactor;
          if(Math.random() < p) cand.state="bad";
        }
      }

      computeQuality();

      // Cost: base from existing bad/dup; reduced if patched late; amplified by how far unpatched error replicated
      let lateWeightSum = 0;
      for(const r of game.records){
        // evaluate "effective" error per system position
        if(r.state==="good") continue;

        // if everything up to repTo is patched, late cost is reduced, but still some admin overhead
        const patchedAll = (r.localFixTo >= r.repTo && r.repTo >= 2)
                       || ((r.state==="dupA"||r.state==="dupB") && r.localMergeTo >= r.repTo && r.repTo >= 2);
        const baseAdmin = patchedAll ? 0.25 : 0.0;

        const frac = (r.repTo / Math.max(1, (game.systems.length-1)));
        const weight = (patchedAll ? (0.45 + frac*0.55) : (0.6 + frac*1.6)) + baseAdmin;
        lateWeightSum += weight;
      }

      game.metrics.cost += lateWeightSum * L.costPerBadPerSec * dt;

      // Score: reward quality & time, small mdm bonus
      game.metrics.score += Math.round((game.metrics.quality - 70) * 0.02);
      game.metrics.score += (game.mdm ? 1 : 0);
      game.metrics.timeSpent += dt * L.timeWeight;

      maybePropagationEvent(dt);
      maybeImpact(dt);

      if(game.sessionOn && game.sessionState==="live"){
        game.sessionLeft = Math.max(0, game.sessionLeft - dt);
        if(game.sessionLeft <= 0){
          game.sessionState = "ended";
          if(!baseline.taken) snapshotBaseline();
        }
      }
    }

    // =========================
    // Movement (masters stay near origin)
    // + "bad floats up" to be reachable
    // =========================
    function step(dt){
      const origin = game.systems[0] || {x:game.viewport.w/2, y:game.viewport.h/2};
      const topBand = 46;

      for(const r of game.records){
        const t = (now() + r.jitter) * 0.001;
        const ox = Math.cos(t*1.5) * 48;
        const oy = Math.sin(t*1.2) * 38;

        r.vx += rnd(-10,10) * dt;
        r.vy += rnd(-10,10) * dt;

        const ax = (origin.x+ox - r.x) * 1.0;
        const ay = (origin.y+oy - r.y) * 1.0;
        r.vx += ax * dt;
        r.vy += ay * dt;

        if(r.state==="bad") r.vy -= 42 * dt;

        r.vx *= (1 - 0.78*dt);
        r.vy *= (1 - 0.78*dt);

        r.x += r.vx * dt;
        r.y += r.vy * dt;

        const pad = 18;
        if(r.x < pad){ r.x=pad; r.vx*=-0.6; }
        if(r.y < pad){ r.y=pad; r.vy*=-0.6; }
        if(r.x > game.viewport.w-pad){ r.x=game.viewport.w-pad; r.vx*=-0.6; }
        if(r.y > game.viewport.h-pad){ r.y=game.viewport.h-pad; r.vy*=-0.6; }

        if(r.state==="bad" && r.y < topBand) r.y = topBand;
      }
    }

    // =========================
    // Drawing helpers
    // =========================
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }
    function drawHeart(x,y,s,stroke){
      ctx.save();
      ctx.strokeStyle = stroke; ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.bezierCurveTo(x - s, y - s, x - 2*s, y + s/2, x, y + 2*s);
      ctx.bezierCurveTo(x + 2*s, y + s/2, x + s, y - s, x, y);
      ctx.stroke();
      ctx.restore();
    }
    function wrapText(text, x, y, maxWidth, lineHeight){
      const words = String(text).split(" ");
      let line="", yy=y;
      ctx.textAlign="left"; ctx.textBaseline="middle";
      for(let n=0;n<words.length;n++){
        const testLine = line + words[n] + " ";
        if(ctx.measureText(testLine).width > maxWidth && n>0){
          ctx.fillText(line, x, yy);
          line = words[n] + " ";
          yy += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, yy);
    }

    // =========================
    // End card / share
    // =========================
    function drawEndCard(){
      const W=game.viewport.w, H=game.viewport.h;
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,.45)";
      ctx.fillRect(0,0,W,H);

      const pw = Math.min(560, W-26), ph=260;
      const px=(W-pw)/2, py=(H-ph)/2;

      ctx.fillStyle="rgba(17,24,39,.92)";
      ctx.strokeStyle="rgba(255,255,255,.14)";
      ctx.lineWidth=1;
      ctx.beginPath(); roundRect(ctx, px, py, pw, ph, 20); ctx.fill(); ctx.stroke();

      ctx.fillStyle="rgba(255,255,255,.92)";
      ctx.font="950 20px system-ui";
      ctx.textAlign="left"; ctx.textBaseline="middle";
      ctx.fillText("Love your Data üíô ‚Äì Session Ergebnis", px+18, py+34);

      ctx.fillStyle="rgba(156,163,175,.95)";
      ctx.font="700 13px system-ui";
      ctx.fillText(el("lvlLbl").textContent, px+18, py+60);

      ctx.fillStyle=getCSS("--mdm-blue");
      ctx.font="950 34px system-ui";
      ctx.fillText(`Score ${Math.round(game.metrics.score)}`, px+18, py+102);

      const q = Math.round(game.metrics.quality);
      ctx.fillStyle="rgba(255,255,255,.86)";
      ctx.font="850 14px system-ui";

      ctx.strokeStyle="rgba(255,255,255,.10)";
      ctx.beginPath(); ctx.moveTo(px+18, py+150); ctx.lineTo(px+pw-18, py+150); ctx.stroke();

      if(baseline.taken){
        const cur = { quality: Math.round(game.metrics.quality), cost: Math.round(game.metrics.cost), score: Math.round(game.metrics.score) };
        const aLabel = baseline.mdmState ? "Mit MDM (Baseline)" : "Ohne MDM (Baseline)";
        const bLabel = game.mdm ? "Mit MDM (Jetzt)" : "Ohne MDM (Jetzt)";

        ctx.font="700 12.5px system-ui";
        ctx.fillStyle="rgba(156,163,175,.95)";
        ctx.fillText(`${aLabel}: Q ${baseline.quality}% ‚Ä¢ ${fmtEuro(baseline.cost)} ‚Ä¢ S ${baseline.score}`, px+18, py+176);

        ctx.fillStyle=getCSS("--mdm-blue");
        ctx.fillText(`${bLabel}: Q ${cur.quality}% ‚Ä¢ ${fmtEuro(cur.cost)} ‚Ä¢ S ${cur.score}`, px+18, py+198);

        const dq = cur.quality - baseline.quality;
        const dc = baseline.cost - cur.cost;
        const ds = cur.score - baseline.score;

        ctx.fillStyle="rgba(255,255,255,.86)";
        ctx.font="900 13px system-ui";
        ctx.fillText(`Œî Qualit√§t ${dq>=0?"+":""}${dq}%   Œî Kosten ${dc>=0?"-":"+"}${fmtEuro(Math.abs(dc))}   Œî Score ${ds>=0?"+":""}${ds}`, px+18, py+226);
      } else {
        ctx.fillStyle="rgba(156,163,175,.95)";
        ctx.font="700 12.5px system-ui";
        ctx.fillText("Tipp: zweite Runde starten f√ºr Vergleich (mit/ohne MDM).", px+18, py+188);
      }

      ctx.fillStyle="rgba(156,163,175,.9)";
      ctx.font="700 12px system-ui";
      ctx.fillText("Share: Button oben ‚Ä¢ Reset: neue Runde", px+18, py+248);
      ctx.restore();
    }

    async function shareCanvasPNG(){
      const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/png", 1.0));
      if(!blob){ toast("Export fehlgeschlagen.", "Share"); return; }
      const file = new File([blob], "love-your-data.png", { type:"image/png" });

      if(navigator.canShare && navigator.canShare({ files:[file] })){
        try{
          await navigator.share({ files:[file], title:"Love your Data ‚Äì Ergebnis", text:"Stammdatenqualit√§t spielerisch erkl√§rt." });
          toast("Geteilt ‚úîÔ∏è", "Share");
          return;
        }catch(e){}
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href=url; a.download="love-your-data.png";
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
      toast("PNG gespeichert ‚úîÔ∏è", "Share");
    }

    // =========================
    // Rendering
    // =========================
    function draw(){
      const W=game.viewport.w, H=game.viewport.h;
      ctx.clearRect(0,0,W,H);

      // subtle grid
      ctx.save();
      ctx.globalAlpha=0.08;
      ctx.strokeStyle="white";
      ctx.lineWidth=1;
      const stepG=38;
      for(let x=0;x<W;x+=stepG){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for(let y=0;y<H;y+=stepG){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
      ctx.restore();

      // connections (system chain)
      ctx.save();
      ctx.lineWidth=3;
      for(let i=0;i<game.systems.length;i++){
        const a=game.systems[i];
        if(i<game.systems.length-1){
          const b=game.systems[i+1];
          ctx.strokeStyle="rgba(255,255,255,.14)";
          ctx.beginPath();
          ctx.moveTo(a.x,a.y);
          ctx.quadraticCurveTo((a.x+b.x)/2, (a.y+b.y)/2 - 40, b.x, b.y);
          ctx.stroke();
          drawHeart(lerp(a.x,b.x,0.5), lerp(a.y,b.y,0.5)-22, 7, "rgba(255,255,255,.14)");
        }
      }
      ctx.restore();

      // systems
      const mdmBlue = getCSS("--mdm-blue");
      for(const s of game.systems){
        ctx.save();
        ctx.fillStyle="rgba(255,255,255,.06)";
        ctx.strokeStyle="rgba(255,255,255,.18)";
        ctx.lineWidth=2.2;
        ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); ctx.stroke();

        if(game.mdm){
          ctx.globalAlpha=0.18;
          ctx.strokeStyle=mdmBlue;
          ctx.lineWidth=3;
          ctx.beginPath(); ctx.arc(s.x,s.y,s.r+12,0,Math.PI*2); ctx.stroke();
          ctx.globalAlpha=1;
        }

        ctx.globalAlpha=0.92;
        ctx.fillStyle="rgba(255,255,255,.86)";
        ctx.font="900 13px system-ui";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(s.label, s.x, s.y-0.5);

        ctx.globalAlpha=0.7;
        ctx.font="800 10.5px system-ui";
        const tag = (s.idx<=1) ? "Quelle" : "Nutzung";
        ctx.fillText(tag, s.x, s.y+18);

        ctx.restore();
      }

      // draw replica ghosts first + store hit hints implicitly via deterministic offsets
      ctx.save();
      for(const r of game.records){
        if(r.repTo <= 0) continue;

        for(let i=1;i<=r.repTo;i++){
          const s = game.systems[i];
          if(!s) continue;

          const st = effectiveStateAtSys(r, i);
          const col = (st==="good") ? "rgba(34,197,94,.22)"
                    : (st==="bad")  ? "rgba(239,68,68,.28)"
                    :                "rgba(245,158,11,.26)";

          const t = (r.jitter + i*777) * 0.001;
          const ox = Math.cos(t*1.3) * 14;
          const oy = Math.sin(t*1.1) * 10;

          // if it is a local patch/mapping, show a tiny mark
          const patched = (r.localFixTo >= i && i>=2);
          const mapped  = ((r.state==="dupA"||r.state==="dupB") && r.localMergeTo >= i && i>=2);

          ctx.fillStyle = col;
          const rr = (patched || mapped) ? 5.0 : 4.2;
          ctx.beginPath();
          ctx.arc(s.x+ox, s.y+oy, rr, 0, Math.PI*2);
          ctx.fill();

          if(patched){
            ctx.strokeStyle="rgba(255,255,255,.20)";
            ctx.lineWidth=1;
            ctx.beginPath();
            ctx.moveTo(s.x+ox-3.0, s.y+oy);
            ctx.lineTo(s.x+ox+3.0, s.y+oy);
            ctx.stroke();
          }
          if(mapped){
            ctx.strokeStyle="rgba(255,255,255,.22)";
            ctx.lineWidth=1;
            ctx.beginPath();
            ctx.arc(s.x+ox, s.y+oy, 2.2, 0, Math.PI*2);
            ctx.stroke();
          }
        }
      }
      ctx.restore();

      // render order: good -> dup -> bad (bad last)
      const order = (st)=> (st==="bad"? 2 : (st==="dupA"||st==="dupB") ? 1 : 0);
      const recs = [...game.records].sort((a,b)=>order(a.state)-order(b.state));

      for(const r of recs){
        const col = (r.state==="good") ? "rgba(34,197,94,1)"
                  : (r.state==="bad")  ? "rgba(239,68,68,1)"
                  :                      "rgba(245,158,11,1)";

        // glow
        ctx.save();
        ctx.globalAlpha = (r.state==="good") ? 0.12 : 0.20;
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(r.x,r.y,r.r+8,0,Math.PI*2); ctx.fill();
        ctx.restore();

        // body
        ctx.save();
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.fill();

        ctx.fillStyle="rgba(0,0,0,.45)";
        ctx.font="900 12px system-ui";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        let t="‚úì"; if(r.state==="bad") t="!"; if(r.state==="dupA"||r.state==="dupB") t="‚âã";
        ctx.fillText(t, r.x, r.y+0.5);
        ctx.restore();

        // dup link
        if((r.state==="dupA"||r.state==="dupB") && r.link){
          const other = game.records.find(x=>x.id===r.link);
          if(other){
            ctx.save();
            ctx.strokeStyle="rgba(245,158,11,.22)";
            ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(r.x,r.y); ctx.lineTo(other.x,other.y); ctx.stroke();
            ctx.restore();
          }
        }
      }
      // Task UI is rendered as bottom sheet (12.5)
      // (Canvas no longer draws task card)

      // quality badge
      const q=game.metrics.quality;
      ctx.save();
      ctx.globalAlpha=0.92;
      ctx.fillStyle="rgba(17,24,39,.55)";
      ctx.strokeStyle="rgba(255,255,255,.10)";
      ctx.lineWidth=1;
      const bw=168,bh=44;
      ctx.beginPath(); roundRect(ctx, W-bw-10, 10, bw, bh, 14); ctx.fill(); ctx.stroke();
      ctx.fillStyle=qualityColor(q);
      ctx.font="950 16px system-ui";
      ctx.textAlign="left"; ctx.textBaseline="middle";
      ctx.fillText(`Qualit√§t: ${Math.round(q)}%`, W-bw, 10+bh/2);
      ctx.restore();

      // system popup
      if(game.systemPopup.active && game.systemPopup.data){
        const {title,text,impact} = game.systemPopup.data;
        ctx.save();
        ctx.globalAlpha=0.95;
        ctx.fillStyle="rgba(17,24,39,.92)";
        ctx.strokeStyle="rgba(255,255,255,.14)";
        ctx.lineWidth=1;

        const w=Math.min(360, W-40), h=150;
        const x=clamp(game.systemPopup.x - w/2, 20, W-w-20);
        const y=clamp(game.systemPopup.y + 40, 20, H-h-20);

        ctx.beginPath(); roundRect(ctx,x,y,w,h,14); ctx.fill(); ctx.stroke();

        ctx.fillStyle="white";
        ctx.font="900 14px system-ui";
        ctx.textAlign="left"; ctx.textBaseline="middle";
        ctx.fillText(title, x+14, y+24);

        ctx.fillStyle="rgba(229,231,235,.9)";
        ctx.font="650 13px system-ui";
        ctx.fillText(text, x+14, y+50);

        ctx.fillStyle="rgba(239,68,68,.92)";
        ctx.font="800 12.5px system-ui";
        ctx.fillText("Folge:", x+14, y+78);

        ctx.fillStyle="rgba(229,231,235,.85)";
        ctx.font="700 12.5px system-ui";
        wrapText(impact, x+64, y+78, w-78, 15);

        if(game.mdm){
          ctx.fillStyle=mdmBlue;
          ctx.font="800 12.5px system-ui";
          ctx.fillText("MDM stoppt fr√ºh (Validierung + Golden Record).", x+14, y+128);
        }
        ctx.restore();
      }

      if(game.sessionOn && game.sessionState==="ended") drawEndCard();
    }

    // =========================
    // Picking
    // =========================
    function getPos(evt){
      const r = canvas.getBoundingClientRect();
      if(evt.touches && evt.touches[0]) return {x: evt.touches[0].clientX - r.left, y: evt.touches[0].clientY - r.top};
      if(evt.changedTouches && evt.changedTouches[0]) return {x: evt.changedTouches[0].clientX - r.left, y: evt.changedTouches[0].clientY - r.top};
      return {x: evt.clientX - r.left, y: evt.clientY - r.top};
    }

    function hitTaskOption(p){
      if(!game.task || !game.taskRects.length) return null;
      for(const r of game.taskRects){
        if(p.x>=r.x && p.x<=r.x+r.w && p.y>=r.y && p.y<=r.y+r.h) return r;
      }
      return null;
    }

    function findRecordAt(p){
      let best=null, bestD=1e9;
      for(const r of game.records){
        const dx=r.x-p.x, dy=r.y-p.y;
        const d=Math.sqrt(dx*dx+dy*dy);
        const extra = (r.state==="bad") ? 10 : 0; // easier to hit bad
        if(d < r.r + 22 + extra && d < bestD){ bestD=d; best=r; }
      }
      return best;
    }

    function findSystemAt(p){
      for(const s of game.systems){
        const dx=p.x-s.x, dy=p.y-s.y;
        const d=Math.sqrt(dx*dx+dy*dy);
        if(d < s.r + 16) return s;
      }
      return null;
    }

    function findReplicaAt(p){
      // find nearest ghost dot; returns {record, sysIdx} or null
      let best=null, bestD=1e9;
      for(const r of game.records){
        if(r.repTo <= 0) continue;
        for(let i=1;i<=r.repTo;i++){
          const s = game.systems[i];
          if(!s) continue;
          const t = (r.jitter + i*777) * 0.001;
          const ox = Math.cos(t*1.3) * 14;
          const oy = Math.sin(t*1.1) * 10;
          const gx = s.x+ox, gy=s.y+oy;
          const dx=gx-p.x, dy=gy-p.y;
          const d=Math.sqrt(dx*dx+dy*dy);
          const hitR = 12; // easy to tap
          if(d < hitR && d < bestD){
            bestD=d;
            best={record:r, sysIdx:i, gx, gy};
          }
        }
      }
      return best;
    }

    // =========================
    // Actions
    // =========================
    function fixOrigin(r){
      if(!r) return;
      if(game.sessionOn && game.sessionState!=="live") return;

      if(r.state==="bad"){
        r.state="good";
        r.localFixTo=-1; // origin fix makes patches unnecessary
        r.localMergeTo=-1;
        r.link=null;
        game.metrics.fixes++;
        game.metrics.score += 40;
        toast("Fix ‚úîÔ∏é ‚Äî Ursprung bereinigt (wirkt in allen Systemen).", "Ursprung", "info", 2.8, true);
      } else if(r.state==="dupA" || r.state==="dupB"){
        toast("Orange = Dublette. Long-Press = Merge (Golden Record).", "Dubletten", "info", 3.2, true);
      } else {
        
      }
    }

    function localFixReplica(r, sysIdx){
      if(!r) return;
      if(game.sessionOn && game.sessionState!=="live") return;
      if(sysIdx < 2) return; // early fix should happen at origin
      if(r.state==="good") return;

      if(!game.help.seenGhostTip){
        game.help.seenGhostTip = true;
        toast("Replikat-Tap = Downstream-Fix: teuer, symptomatisch, kann zur√ºckkommen.", "Tipp");
      }

      const isDup = (r.state==="dupA" || r.state==="dupB");

      const base = isDup ? 210 : 160;
      const per  = isDup ? 180 : 160;
      const spike = base + (sysIdx-1)*per * (game.mdm ? 0.65 : 1.0);

      if(isDup){
        r.localMergeTo = Math.max(r.localMergeTo, sysIdx);
        game.metrics.fixes++;
        game.metrics.cost += spike;
        game.metrics.score -= Math.round(34 + sysIdx*9);
        toast(`üîó Downstream-Mapping in <b>${game.systems[sysIdx]?.label || ("SYS "+(sysIdx+1))}</b> ‚Äî Dublette am Ursprung bleibt <span class="tag">+${fmtEuro(spike)}</span>`, "Folgesystem");
      } else {
        r.localFixTo = Math.max(r.localFixTo, sysIdx);
        game.metrics.fixes++;
        game.metrics.cost += spike;
        game.metrics.score -= Math.round(28 + sysIdx*8);
        toast(`ü©π Lokalfix in <b>${game.systems[sysIdx]?.label || ("SYS "+(sysIdx+1))}</b> ‚Äî teuer, Ursprung bleibt falsch <span class="tag">+${fmtEuro(spike)}</span>`, "Folgesystem");
      }
    }

    function mergeDupPair(r){
      if(!r) return false;
      if(game.sessionOn && game.sessionState!=="live") return false;
      if(!(r.state==="dupA" || r.state==="dupB") || !r.link) return false;

      const otherIndex = game.records.findIndex(x=>x.id===r.link);
      if(otherIndex < 0) return false;
      const other = game.records[otherIndex];

      r.x = (r.x + other.x)/2;
      r.y = (r.y + other.y)/2;

      r.state="good";
      r.link=null;
      r.localFixTo=-1;
      r.localMergeTo=-1;
      game.records.splice(otherIndex,1);

      game.metrics.fixes += 2;
      game.metrics.score += 65;
      toast("Merge üíô ‚Äî Dublette bereinigt (Golden Record).", "Merge");
      return true;
    }


    function healAllWithMdm(){
      if(!game.mdm) return;
      if(game.sessionOn && game.sessionState!=="live") return;

      // Merge duplicate pairs safely
      const done = new Set();
      for(const r of [...game.records]){
        if((r.state==="dupA" || r.state==="dupB") && r.link && !done.has(r.id) && !done.has(r.link)){
          done.add(r.id); done.add(r.link);
          mergeDupPair(r);
        }
      }

      // Fix remaining bad records
      let fixed=0;
      for(const r of game.records){
        if(r.state==="bad"){ r.state="good"; fixed++; }
        r.localFixTo = -1;
        r.localMergeTo = -1;
      }

      const bonus = 80 + fixed*8;
      game.metrics.score += bonus;
      toast(`‚úÖ MDM-Validierung: ${fixed} Fehler automatisch bereinigt.`, "MDM");
    }

    function openSystemPopup(sys){
      const info = SYSTEM_INFO[sys.label];
      if(!info) return;
      game.systemPopup.active=true;
      game.systemPopup.x=sys.x;
      game.systemPopup.y=sys.y;
      game.systemPopup.data=info;
      game.systemPopup.until=now()+4500;
      toast(`${info.title}: ${info.text}`, "System");
    }

    // =========================
    // Input: context-based long press (no conflicts)
    // =========================
    let longPressTimer=null;
    let downAt=0;
    let pressContext=null; // "record" | "system" | "replica" | "task" | null
    let pressTarget=null;

    function onDown(evt){
      evt.preventDefault?.();
      if(game.sessionOn && game.sessionState!=="live") return;

      const p = getPos(evt);
      downAt = now();

      // 1) Task option tap has priority
      const opt = hitTaskOption(p);
      if(opt){
        pressContext="task";
        pressTarget=opt;
        // resolve immediately on down for snappy feel
        resolveTask(!!opt.ok);
        return;
      }

      // 2) Replica tap: allow local fixes
      const rep = findReplicaAt(p);
      if(rep){
        pressContext="replica";
        pressTarget=rep;
      } else {
        // 3) Record > system
        const rec = findRecordAt(p);
        if(rec){
          pressContext="record";
          pressTarget=rec;
        } else {
          const sys = findSystemAt(p);
          if(sys){
            pressContext="system";
            pressTarget=sys;
          } else {
            pressContext=null;
            pressTarget=null;
          }
        }
      }

      clearTimeout(longPressTimer);
      longPressTimer = setTimeout(()=>{
        if(pressContext==="record"){
          if(pressTarget && (pressTarget.state==="dupA"||pressTarget.state==="dupB")) mergeDupPair(pressTarget);
        } else if(pressContext==="system"){
          if(pressTarget) openSystemPopup(pressTarget);
        }
      }, 420);
    }

    function onUp(evt){
      evt.preventDefault?.();

      // close popup with any tap
      if(game.systemPopup.active){
        game.systemPopup.active=false;
        game.systemPopup.data=null;
        return;
      }

      if(game.sessionOn && game.sessionState!=="live") return;

      clearTimeout(longPressTimer);
      const held = now() - downAt;

      // Tap behavior
      if(held < 380){
        if(pressContext==="record" && pressTarget){
          fixOrigin(pressTarget);
        } else if(pressContext==="replica" && pressTarget){
          localFixReplica(pressTarget.record, pressTarget.sysIdx);
        }
      }

      pressContext=null;
      pressTarget=null;
    }

    canvas.addEventListener("touchstart", onDown, {passive:false});
    canvas.addEventListener("touchend",   onUp,   {passive:false});
    canvas.addEventListener("mousedown",  onDown);
    window.addEventListener("mouseup",    onUp);

    // =========================
    // UI toggles
    // =========================
    function syncMdmUI(){
      const L = LEVELS[game.lvlIndex];
      const forced = !!L.forceMdm;
      const btn = el("btnMdm");
      const pill = el("mdmPill");

      if(game.mdm){
        btn.textContent = forced ? "MDM: On (locked)" : "MDM: On";
        pill.style.display="inline-flex";
      } else {
        btn.textContent = "MDM: Off";
        pill.style.display="none";
      }
      const heal = el("btnHeal");
      if(heal){
        heal.style.display = game.mdm ? "inline-flex" : "none";
        heal.disabled = !game.mdm;
      }
      btn.disabled = forced;
      btn.style.opacity = forced ? 0.6 : 1;
    }
    function syncSessionUI(){
      el("btnSession").textContent = `Session: ${game.sessionOn ? "On" : "Off"}`;
      el("timerPill").style.display = game.sessionOn ? "inline-flex" : "none";
    }
    function syncDemoUI(){
      el("btnDemo").textContent = `Demo: ${game.demo.on ? "On" : "Off"}`;
    }

    // =========================
    // Demo mode
    // =========================
    function runDemo(dt){
      if(!game.demo.on) return;

      if(game.sessionOn && game.sessionState==="ended"){
        game.demo.autoRestartIn -= dt;
        if(game.demo.autoRestartIn <= 0){
          const L = LEVELS[game.lvlIndex];
          if(!L.forceMdm) game.mdm = !game.mdm;
          syncMdmUI();
          initLevel(game.lvlIndex);

          game.demo.autoRestartIn = 2.2 + Math.random()*1.5;
          game.demo.nextActionIn  = 1.2 + Math.random()*0.8;
        }
        return;
      }

      // Resolve tasks with a short readable delay (demo should be legible)
      if(game.task){
        game.demo.nextActionIn -= dt;
        if(game.demo.nextActionIn > 0) return;
        game.demo.nextActionIn = 1.0 + Math.random()*0.7;

        if(Math.random() < 0.82){ resolveTask(true); } else { resolveTask(false); }
        return;
      }

      game.demo.nextActionIn -= dt;
      if(game.demo.nextActionIn > 0) return;
      game.demo.nextActionIn = 0.55 + Math.random()*0.9;

      const bad = game.records.find(r=>r.state==="bad");
      if(bad){ fixOrigin(bad); return; }

      // sometimes show local fix
      const badLate = game.records.find(r=>r.state==="bad" && r.repTo>=3 && r.localFixTo<3);
      if(badLate){
        localFixReplica(badLate, 3);
        return;
      }

      const dup = game.records.find(r=>(r.state==="dupA"||r.state==="dupB"));
      if(dup){ mergeDupPair(dup); return; }
    }

    // =========================
    // Level init
    // =========================
    function initLevel(idx){
      game.lvlIndex = clamp(idx, 0, LEVELS.length-1);
      const L = LEVELS[game.lvlIndex];
      if(L.forceMdm) game.mdm = true;

      game.metrics = {quality:100, errors:0, dups:0, fixes:0, cost:0, timeSpent:0, score:0};
      game.records = [];
      game.systems = buildSystems(L.systems);

      const origin = game.systems[0] || {x:game.viewport.w/2, y:game.viewport.h/2};
      for(let i=0;i<L.records;i++){
        const r = new Record(origin.x + rnd(-100,100), origin.y + rnd(-80,80));
        r.originSys = 0;
        r.repTo = 0;
        r.localFixTo = -1;
        r.localMergeTo = -1;
        game.records.push(r);
      }

      game.sessionLen = L.sessionLen || 120.0;
      game.sessionLeft = game.sessionLen;
      game.sessionState = "live";

      game.task=null;
      if(!game.task){ game.nextTaskAt = now() + (game.mdm ? 7.0 : (6.0 + Math.random()*6.0)); }
      game.taskRects=[];
      game.taskUntil=0;

      game.nextImpactIn = 8.0 + Math.random()*6.5;
      game.nextEventIn  = 7.5 + Math.random()*7.0;

      game.systemPopup.active=false;
      game.systemPopup.data=null;

      el("lvlLbl").textContent = `Level ${L.id}: ${L.name}`;
      syncMdmUI(); syncSessionUI(); syncDemoUI();
      tutorialStartIfLevel1();

      toast(`Start: <b>${L.name}</b>`, "Go");
    }

    // =========================
    // Buttons
    // =========================
    el("btnPrev").addEventListener("click", ()=>initLevel(game.lvlIndex-1));
    el("btnNext").addEventListener("click", ()=>initLevel(game.lvlIndex+1));

    el("btnMdm").addEventListener("click", ()=>{
      const L = LEVELS[game.lvlIndex];
      if(L.forceMdm) return;
      game.mdm = !game.mdm;
      // MDM removes need for local patches
      if(game.mdm){
        for(const r of game.records){ r.localFixTo = -1; r.localMergeTo = -1; }
      }
      syncMdmUI();
      toast(game.mdm ? "MDM aktiviert ‚Äî weniger Entstehung + bessere Verteilungskontrolle." : "MDM deaktiviert ‚Äî mehr Entstehung & sp√§te Folgen.", "MDM");
    });

    el("btnSession").addEventListener("click", ()=>{
      game.sessionOn = !game.sessionOn;
      syncSessionUI();
      toast(game.sessionOn ? `Session-Modus: ${Math.round(LEVELS[game.lvlIndex].sessionLen || 120)}s Challenge` : "Freies Spiel (ohne Timer)", "Session");
      initLevel(game.lvlIndex);
    });

    el("btnDemo").addEventListener("click", ()=>{
      game.demo.on = !game.demo.on;
      syncDemoUI();
      toast(game.demo.on ? "Auto-Demo aktiv (Messe-Modus)" : "Auto-Demo aus", "Demo");
    });

    el("btnShare").addEventListener("click", ()=>shareCanvasPNG());
    el("btnHeal").addEventListener("click", ()=>healAllWithMdm());
        // --- Mini Game: Data Zen (Memory) ---
    // Pops up after longer cleanliness in MDM mode. Calm, quick, mobile-friendly.
    const mini = {
      active:false,
      lastOpenAt:-999,
      cooldown:60.0,        // seconds between opens
      bonusAwarded:false,
      matches:0,
      bonus:0,
      first:null,
      lock:false,
      values:[]
    };

    function miniSetup(){
      // 6 pairs (duplicates) -> 12 tiles
      const base = ["KUNDE 17","KUNDE 42","LIEF 08","MAT 1337","ADR 05","PAY 21"];
      const vals = base.concat(base);
      // shuffle
      for(let i=vals.length-1;i>0;i--){
        const j=(Math.random()*(i+1))|0;
        [vals[i], vals[j]] = [vals[j], vals[i]];
      }
      mini.values = vals;
      mini.matches = 0;
      mini.first = null;
      mini.lock = false;
      mini.bonus = 0;
      mini.bonusAwarded = false;
      el("miniScore").textContent = "0";
      el("miniBonus").textContent = "0";

      const grid = el("miniGrid");
      grid.innerHTML = "";
      vals.forEach((v, idx)=>{
        const t = document.createElement("button");
        t.className = "miniTile";
        t.type = "button";
        t.dataset.idx = String(idx);
        t.dataset.val = v;
        t.innerHTML = `<div class="face back">üíô</div><div class="face front" style="display:none">${v}</div>`;
        t.addEventListener("click", ()=>miniFlip(t));
        grid.appendChild(t);
      });
    }

    function miniFlip(tile){
      if(!mini.active || mini.lock) return;
      if(tile.classList.contains("matched") || tile.classList.contains("flipped")) return;

      tile.classList.add("flipped");
      tile.querySelector(".back").style.display = "none";
      tile.querySelector(".front").style.display = "flex";

      if(!mini.first){
        mini.first = tile;
        return;
      }

      const a = mini.first;
      const b = tile;
      mini.first = null;

      if(a.dataset.val === b.dataset.val){
        a.classList.add("matched");
        b.classList.add("matched");
        mini.matches++;
        el("miniScore").textContent = String(mini.matches);

        if(mini.matches >= 6){
          miniAwardBonus(true);
          setTimeout(()=>closeMini(), 650);
        }
      } else {
        mini.lock = true;
        setTimeout(()=>{
          for(const t of [a,b]){
            t.classList.remove("flipped");
            t.querySelector(".back").style.display = "flex";
            t.querySelector(".front").style.display = "none";
          }
          mini.lock = false;
        }, 520);
      }
    }

    function miniAwardBonus(completed=false){
      if(mini.bonusAwarded) return;
      const base = completed ? 180 : 90;
      const award = base + mini.matches*25;
      mini.bonus = award;
      mini.bonusAwarded = true;
      el("miniBonus").textContent = String(award);
      game.metrics.score += award;
      toast(`‚ú® Bonus: ruhiger Betrieb <span class="tag">+${award} Punkte</span>`, "MDM");
    }

    function openMini(){
      if(mini.active) return;
      mini.active = true;
      mini.lastOpenAt = now();
      el("miniWrap").classList.remove("hidden");
      game.miniPaused = true;
      miniSetup();
    }

    // 14.2: public trigger for the Zen minigame (demo button / console)
    function startZenGame(){
      try{
        if(typeof mini !== 'undefined' && mini && mini.active) return;
        openMini();
      }catch(e){
        console.error(e);
      }
    }
    window.startZenGame = startZenGame;

    


    function closeMini(){
      if(!mini.active) return;
      mini.active = false;
      game.miniPaused = false;
      try{ requestAnimationFrame(frame); }catch(e){}
      el("miniWrap").classList.add("hidden");
      game.miniPaused = false;
      if(!mini.bonusAwarded){
        miniAwardBonus(false);
      }
    }

el("btnReset").addEventListener("click", ()=>{
      if(baseline.taken){
        const L = LEVELS[game.lvlIndex];
        if(!L.forceMdm) game.mdm = !game.mdm;
        syncMdmUI();
      }
      initLevel(game.lvlIndex);
    });

    // =========================
    // Main loop
    // =========================
    let last = now();
    function frame(){
      const t = now();
      const dt = clamp((t-last)/1000, 0, 0.033);
      last = t;

      // toast auto-hide
      const toastEl = el("toast");
      if(toastEl.classList.contains("show") && (t - game.toastAt) > 3200) toastEl.classList.remove("show");

      // popup auto-hide
      if(game.systemPopup.active && t > game.systemPopup.until){
        game.systemPopup.active=false;
        game.systemPopup.data=null;
      }

      tutorialTick();

      if(!(game.sessionOn && game.sessionState==="ended")){
        spreadTick(dt);
      // Positive feedback when data stays clean
      const sig = incidentSignal();
      if(sig.late===0){
        game.cleanTime += dt;
      } else {
        game.cleanTime = 0;
      }
      // Easter egg: after longer cleanliness in MDM, open a calm mini game
      const miniReady = game.mdm && game.cleanTime > 26 && !mini.active && (now() - mini.lastOpenAt) > mini.cooldown;
      if(miniReady){
        openMini();
        game.nextCleanToast = game.cleanTime + 18.0 + Math.random()*10.0;
        requestAnimationFrame(frame);
        return;
      }

      if(game.cleanTime > game.nextCleanToast && game.cleanTime > 8){
        game.nextCleanToast = game.cleanTime + 14.0 + Math.random()*8.0;
        if(game.mdm){
          toast("‚úÖ Ruhiger Betrieb: saubere Stammdaten, kaum Support.", "MDM");
        } else {
          toast("‚úÖ Alles ruhig: saubere Daten zahlen sich aus.", "Qualit√§t");
        }
      }
        step(dt);
      }

      runDemo(dt);
      draw();
      updateHUD();
      renderTaskSheet();

      requestAnimationFrame(frame);
    }

    // Boot


    // 14.4: bind mini close after DOM is ready + alias for demos
    window.addEventListener('DOMContentLoaded', ()=>{
      const closeBtn = document.getElementById('btnMiniClose');
      if(closeBtn) closeBtn.addEventListener('click', closeMini);
      window.zen = ()=>{ try{ if(typeof window.startZenGame==='function') window.startZenGame(); }catch(e){ console.error(e); } };
    });

// Boot
    resize();
    initLevel(0);
    requestAnimationFrame(frame);
  
    // --- Console hooks (debug/demo) ---
    // Use in DevTools:
    //   lyd.mini()        -> open Data Zen
    //   lyd.miniClose()   -> close
    //   lyd.mdmOn() / lyd.mdmOff()
    //   lyd.clean()       -> force clean state (all good, no dups)
    //   lyd.level(n)      -> go to level 1..N
    window.lyd = {
      mini: ()=>openMini(),
      miniClose: ()=>closeMini(),
      mdmOn: ()=>{ game.mdm=true; syncMdmUI(); toast("MDM: On (console)", "MDM"); },
      mdmOff: ()=>{ game.mdm=false; syncMdmUI(); toast("MDM: Off (console)", "MDM"); },
      clean: ()=>{ for(const r of game.records){ r.state="good"; r.link=null; r.localFixTo=-1; r.localMergeTo=-1; r.repTo=Math.max(r.repTo,0);} toast("Alles sauber (console).", "Qualit√§t"); },
      level: (n)=>{ const idx=Math.max(0, Math.min(LEVELS.length-1, (n|0)-1)); game.lvlIndex=idx; initLevel(); toast(`Level ${idx+1} (console)`, "Level"); }
    };


    // 11.4: Robust HUD toggle (no dependency on helper funcs)
    (function(){
      const btn = document.getElementById("hudToggle");
      if(!btn) return;
      function apply(collapsed){
        document.body.classList.toggle("hudCollapsed", !!collapsed);
        try{ localStorage.setItem("lyd_hudCollapsed", collapsed ? "1":"0"); }catch(e){}
      }
      btn.addEventListener("click", ()=>{
        const collapsed = !document.body.classList.contains("hudCollapsed");
        apply(collapsed);
      }, {passive:true});

      // restore pref
      let pref = null;
      try{ pref = localStorage.getItem("lyd_hudCollapsed"); }catch(e){}
      if(pref === "1") apply(true);

      // auto-collapse on mobile if no pref set
      if(window.innerWidth <= 520 && pref === null){
        setTimeout(()=>{ apply(true); }, 2200);
      }
    })();


    (function(){
      const t = document.getElementById("hudLevelTiny");
      if(!t) return;
      function upd(){
        try{
          if(typeof game!=="undefined" && typeof LEVELS!=="undefined"){
            const lvl = LEVELS[game.lvlIndex] || {name:""};
            t.textContent = ("Level " + (game.lvlIndex+1) + ": " + (lvl.name||"")).trim();
          }
        }catch(e){}
      }
      upd();
      setInterval(upd, 1200);
    })();


    // 12.5 dynamic canvas height (fill space between header and task sheet)
    
    function clampStatsToFour(){
      const grids = [
        document.querySelector('#hudWrap .stats'),
        document.querySelector('.hud .stats'),
        document.getElementById('stats'),
        document.querySelector('.hudStats')
      ].filter(Boolean);
      for(const g of grids){
        const kids = Array.from(g.children);
        for(let i=4;i<kids.length;i++){
          kids[i].style.display = 'none';
        }

    function pruneStats(){
      const allowed = ["qualit√§t","systeme","datens√§tze","datensaetze","dubletten"];
      const grids = [
        document.querySelector('#hudWrap .stats'),
        document.querySelector('.hud .stats'),
        document.getElementById('stats'),
        document.querySelector('.hudStats')
      ].filter(Boolean);
      for(const g of grids){
        const kids = Array.from(g.children);
        for(const el of kids){
          // Find a likely label node inside tile
          const labelNode = el.querySelector('.label, .statLabel, .stat-label, .k, .name, .t');
          const labelTxt = (labelNode ? labelNode.textContent : el.textContent || "").trim().toLowerCase();
          // Keep if matches allowed; otherwise hide
          const ok = allowed.some(a => labelTxt.includes(a));
          if(!ok){
            el.style.display = 'none';
          }
        }
        // Ensure only first 4 visible tiles remain (in case labels are weird)
        const vis = Array.from(g.children).filter(x => getComputedStyle(x).display !== 'none');
        for(let i=4;i<vis.length;i++) vis[i].style.display='none';
      }
    }
      }
    }

function layoutTight(){
      const stage = document.querySelector('.stage');
      const task = document.getElementById('taskSheet');
      const header = document.querySelector('.hudToggle');
      if(!stage) return;
      let h = window.innerHeight;
      if(header) h -= header.getBoundingClientRect().height;
      let taskH = 0;
      if(task && task.style.display!=='none'){ taskH = task.getBoundingClientRect().height; h -= taskH; }
      // keep info toast above the task sheet
      const toastBottom = (taskH>0 ? (taskH + 14) : 0);
      document.documentElement.style.setProperty('--toastBottom', toastBottom ? (toastBottom + 'px') : '');
      
      // 12.5: place info toasts under stats
      const hudStats = document.querySelector('#hudWrap .hud');
      if(hudStats){
        const r = hudStats.getBoundingClientRect();
        const top = Math.max(12, r.bottom + 10);
        document.documentElement.style.setProperty('--toastTop', top + 'px');
      // 13.2: toast zone top under stats
      document.documentElement.style.setProperty('--toastZoneTop', top + 'px');

      }
      stage.style.height = Math.max(280, h) + 'px';
    }
    window.addEventListener('resize', ()=>{ layoutTight();
    clampStatsToFour();
    pruneStats();
 hideHudFields();
    hideExtraHudRows(); });


    
    // 14.4: Zen button handler (toolbar + safe fallback)
    (function(){
      const btn = document.getElementById('btnZen');
      if(!btn) return;
      btn.addEventListener('click', ()=>{
        try{
          console.log('[Zen] click');
          if(typeof window.startZenGame === 'function'){ window.startZenGame(); return; }
          if(window.lyd && typeof window.lyd.mini === 'function'){ window.lyd.mini(); return; }
          console.warn('Zen game function not found');
        }catch(e){ console.error(e); }
      });
    })();
</script>

  
  <!-- MDM Mini-Game: Data Zen (Memory) -->
  <div id="miniWrap" class="mini hidden">
    <div class="miniCard">
      <div class="miniHead">
        <div class="miniTitle">MDM-Modus üíô ‚Äì Data Zen</div>
        <button id="btnMiniClose" class="miniClose">Schlie√üen</button>
      </div>
      <div class="miniSub">Lange sauber? Dann kurz ‚ÄûDubletten finden‚Äú ‚Äì ganz entspannt üôÇ</div>

      <div class="miniGrid" id="miniGrid" aria-label="Memory Grid"></div>

      <div class="miniFooter">
        <div>Matches: <b id="miniScore">0</b>/6</div>
        <div class="tag">Bonus: +<span id="miniBonus">0</span> Punkte</div>
      </div>
    </div>
  </div>

  </div>

</body>
</html>
<style>
#taskToast { z-index: 30; }
#topToasts { z-index: 20; }
#bottomToasts { display:none !important; }
</style>

<style>
.toastZone{
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  margin-top:8px;
  pointer-events:none;
}
.toastZone .toastCard{
  pointer-events:auto;
}
</style>
